<!DOCTYPE html ><html xml:lang="en" lang="en" data-highlight-require-whitespace="false" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><title>AXI UVM User Interface</title><link rel="Prev" href="03_DataObjects.03.03.html" title="Previous" /><link rel="Next" href="03_DataObjects.03.05.html" title="Next" /><link rel="StyleSheet" href="css/03_DataObjects.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/skin.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/social.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all" /><!--[if IE 7]><link rel="StyleSheet" href="css/03_DataObjects_IE7.css" type="text/css" media="all" /><![endif]--><link rel="StyleSheet" href="css/print.css" type="text/css" media="print" /><script type="text/javascript">
    'use strict';

    var redirect_url, page_hash;

    if ((window === window.top) && (window.navigator.userAgent.indexOf('bot/') === -1)) {
        // Redirect
        //
        redirect_url = "../index.html#page/axi_svt_uvm_user_guide/03_DataObjects.03.04.html";
        if (window.document.location.hash.length > 1) {
            // Sanitize and append it
            //
            page_hash = window.document.location.hash.substring(1);
            page_hash = page_hash.replace(/[\\><:;"]|%5C|%3C|%3E|%3A|%3B|%22/gi, '');

            // escape the '#' character
            //
            redirect_url += '%23' + page_hash;
        }
        window.document.location.replace(redirect_url);
    }
</script><script type="text/javascript" src="scripts/common.js"></script><script type="text/javascript" src="scripts/page.js"></script><script type="text/javascript" src="scripts/search-client.js"></script><script type="text/javascript" src="scripts/unidata.js"></script><script type="text/javascript" src="scripts/unibreak.js"></script><noscript><div id="noscript_padding"></div></noscript></head><body id="pNwz2n_002bLUrBpiRM_002bh48Ka0w" class="ww_skin_page_body" onload="Page.OnLoad('../index.html#page/axi_svt_uvm_user_guide/03_DataObjects.03.04.html');"><header id="wwconnect_header"><div class="ww_skin_breadcrumbs"><a class="WebWorks_Breadcrumb_Link" href="01_Intro.01.1.html">AXI UVM User Guide</a> : <a class="WebWorks_Breadcrumb_Link" href="03_DataObjects.03.01.html#1118844"> General Concepts</a> : AXI UVM User Interface</div><div class="ww_skin_page_toolbar"><a class="ww_behavior_print ww_skin ww_skin_print" title="Print" href="#">&nbsp;</a><a class="ww_behavior_email ww_skin ww_skin_email" title="E-Mail" href="#" target="external_window">&nbsp;</a></div></header><div id="ww1118844" class="H2">AXI UVM User Interface</div><div id="ww1119096" class="Body"><span></span>The following sections give an overview of the user interface into the AXI VIP.</div><div id="ww1153554" class="H3">Clock and Reset Connection</div><div id="ww1154184" class="Body"><span></span>There is a small change in the bind use model starting from from the 1.96a release of AXI VIP. Following are the details of the change:</div><div id="ww1154185" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>For active agent connection:</div><div id="ww1154186" class="L1Body"><span></span>         Pass '1' as the parameter value and svt_axi_master_async_modport as the first argument to the connector.</div><div id="ww1154187" class="L1Code">        bind test_top svt_axi_master_connector #(1) master_bind_connector0(axi_if.master_if[0].svt_axi_master_async_modport, slave_dut.master_bind_if);</div><div id="ww1154189" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>For passive agent connection:</div><div id="ww1154190" class="L1Body"><span></span>        Pass '0' as the parameter value and svt_axi_monitor_modport as the first argument to the connector.</div><div id="ww1154191" class="L1Code">        bind test_top svt_axi_master_connector #(0) master_bind_connector0(axi_if.master_if[0].svt_axi_monitor_modport, slave_dut.master_bind_if);</div><div id="ww1154178" class="H3">VIP Interface Connection </div><div id="ww1154255" class="Body"><span></span>AXI VIP provides the SystemVerilog interface which can be used to connect the VIP to the DUT. A top level interface svt_axi_if is provided which contains an array of master &amp; slave interfaces. </div><div id="ww1154256" class="Body"><span></span>For example,</div><div id="ww1154257" class="L1Code">/* instantiate top level interface*/ </div><div id="ww1154258" class="L1Code">svt_axi_if axi_if(); </div><div id="ww1154259" class="Body"><span></span>There are two ways on how you can set clock signal "aclk" for each/all of master and slave sub interfaces under this top level svt_axi_if interface instance. </div><div id="ww1154260" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>If you want to use a common clock for all the master and slave port interfaces, there is 'common_aclk' signal at svt_axi_if level , which can be used. This common clock will then be used by all the port interfaces. </div><div id="ww1154262" class="L1Body"><span></span>For example, </div><div id="ww1154263" class="L1Code">svt_axi_if axi_if(); </div><div id="ww1154264" class="L1Code">assign axi_if.common_aclk = SystemClock; </div><div id="ww1154265" class="Body"><span></span>&nbsp;</div><div class="ww_skin_page_overflow"><table class="Note" style="width: 540.75024pt" cellspacing="0" summary=""><tr><td style="padding-bottom: 6pt; padding-left: 6pt; padding-right: 10pt; padding-top: 6pt; vertical-align: top; width: 77.99976pt"><div id="ww1166770" class="Z_Note"><span><img src="Note.gif" alt="*" border="0" width="100" height="27" /></span>&nbsp;</div></td><td style="padding-bottom: 6pt; padding-left: 6pt; padding-right: 10pt; padding-top: 6pt; vertical-align: top; width: 462.75048pt"><div id="ww1166772" class="TableBody"><span></span>You must leave svt_axi_system_configuration::common_clock_mode set to default value '1' for system configuration object.</div></td></tr></table></div><div id="ww1154266" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>If any/all master/slave port interface under svt_axi_if instance need to use a separate clock, then the 'aclk' signal in the port interface should be connected to respective individual clocks and system configuration object field " svt_axi_system_configuration::common_clock_mode" should be set to '0' to disable common clock mode. </div><div id="ww1119103" class="H3">Configuration Objects</div><div id="ww1121785" class="Body"><span></span>Configuration data objects convey the system level and port level testbench configuration. The configuration of agents is done in the <span class="Code">build() </span>phase of environment or the testcase. If the configuration needs to be changed later, it can be done through reconfigure() method of the Master, Slave Agent or System Env. </div><div id="ww1119113" class="Body"><span></span>The configuration can be of the following two types:</div><div id="ww1119143" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Static configuration properties</div><div id="ww1123805" class="L1Body"><span></span>Static configuration parameters specify a configuration value which cannot be changed when the system is running. Examples of static configuration parameters are number of masters and slaves, data bus width, and address width.</div><div id="ww1119195" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Dynamic configuration properties</div><div id="ww1123816" class="L1Body"><span></span>Dynamic configuration parameters specify configuration value which can be changed at any time, regardless of whether the system is running or not. An example of a dynamic configuration parameter is a timeout value.</div><div id="ww1121850" class="Body"><span></span>The configuration data objects contain built-in constraints, which come into effect when the configuration objects are randomized.</div><div id="ww1119206" class="Body"><span></span>The AXI VIP defines following configuration classes:</div><div id="ww1119207" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>System configuration (<span class="Code">svt_axi_system_configuration</span>)</div><div id="ww1123841" class="L1Body"><span></span>The System configuration class contains configuration information which is applicable across the entire system. You can specify the system level configuration parameters through this class. You need to provide the system configuration to the system env from the environment or the testcase. The system configuration mainly specifies:</div><div id="ww1119210" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>Number of master and slave agents in the system env</div><div id="ww1121007" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>Port configurations for master and slave agents</div><div id="ww1119211" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>Virtual top level AXI interface</div><div id="ww1119212" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>Address map</div><div id="ww1119213" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>Timeout values</div><div id="ww1119214" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Port configuration (<span class="Code">svt_axi_port_configuration</span>)</div><div id="ww1123851" class="L1Body"><span></span>The Port configuration class contains configuration information which is applicable to individual AXI master or slave agents in the system env. Some of the important information provided by port configuration class is:</div><div id="ww1119216" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>Active or Passive mode of the master or slave port agent</div><div id="ww1119217" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>Enable or disable protocol checks</div><div id="ww1119218" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>Enable or disable port-level coverage</div><div id="ww1119219" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>Interface type (AXI3/AXI4/AXI4-Lite)</div><div id="ww1121872" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>Port configuration contains the virtual interface for the port</div><div id="ww1123862" class="L1Body"><span></span>The port configuration objects within the system configuration object are created in the constructor of the system configuration.</div><div id="ww1132914" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Interconnect configuration (<span class="Code">svt_axi_interconnect_configuration</span>)</div><div id="ww1132916" class="L1Body"><span></span>Interconnect configuration class contains configuration information for the interconnect component. It has a handle to the system configuration. In addition, this class contains configuration for number of master and slave ports of the interconnect component, and the respective configuration for these master and slave ports.</div><div id="ww1123863" class="Body"><span></span>For details on individual members of configuration classes, see the AXI VIP Class reference HTML documentation.</div><div id="ww1119196" class="H3">Transaction Objects</div><div id="ww1119328" class="Body"><span></span>Transaction objects, which are extended from the <span class="Code">uvm_sequence_item</span> base class, define a unit of AXI protocol information that is passed across the bus. The attributes of transaction objects are public and are accessed directly for setting and getting values. Most transaction attributes can be randomized. The transaction object can represent the desired activity to be simulated on the bus, or the actual bus activity that was monitored. </div><div id="ww1119330" class="Body"><span></span>AXI transaction data objects store data content and protocol execution information for AXI transactions in terms of timing details of the transactions. </div><div id="ww1119331" class="Body"><span></span>These data objects extend from the <span class="Code">uvm_sequence_item</span> base class and implement all methods specified by UVM for that class.</div><div id="ww1119332" class="Body"><span></span>AXI transaction data objects are used to:</div><div id="ww1119333" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Generate random stimulus</div><div id="ww1119334" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Report observed transactions</div><div id="ww1119335" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Generate random responses to transaction requests</div><div id="ww1119336" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Collect functional coverage statistics</div><div id="ww1119338" class="Body"><span></span>Class properties are public and accessed directly to set and read values. Transaction data objects support randomization and provide built-in constraints. Two set of constraints are provided: <span class="Code">valid_ranges</span> and reasonable constraints.</div><div id="ww1119339" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">valid_ranges</span> constraints limit generated values to those acceptable to the drivers. These constraints ensure basic VIP operation and should never be disabled. </div><div id="ww1119340" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">reasonable_*</span> constraints, which can be disabled individually or as a block, limit the simulation by the following:</div><div id="ww1119341" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>Enforcing the protocol. These constraints are typically enabled unless errors are being injected into the simulation.</div><div id="ww1119342" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>Setting simulation boundaries. Disabling these constraints may slow the simulation and introduce system memory issues.</div><div id="ww1119343" class="Body"><span></span>The VIP supports extending transaction data classes for customizing randomization constraints. This allows you to disable some <span class="Code">reasonable_*</span> constraints and replace them with constraints appropriate to your system.</div><div id="ww1119344" class="Body"><span></span>Individual <span class="Code">reasonable_*</span> constraints map to independent fields, each of which can be disabled. The class provides the <span class="Code">reasonable_constraint_mode()</span> method to enable or disable blocks of <span class="Code">reasonable_*</span> constraints.</div><div id="ww1137929" class="Body"><span></span>AXI VIP defines following transaction classes:</div><div id="ww1121048" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>AXI Base transaction (<span class="Code">svt_axi_transaction</span>)</div><div id="ww1123895" class="L1Body"><span></span>This is the base transaction type which contains all the physical attributes of the transaction like address, data, burst type, burst length, etc. It also provides the timing information the transaction, to the master and slave drivers, that is, delays for valid and .ready signals with respect to some reference events. </div><div id="ww1121050" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>AXI Master transaction (<span class="Code">svt_axi_master_transaction</span>)</div><div id="ww1123905" class="L1Body"><span></span>The master transaction class extends from the AXI transaction base class <span class="Code">svt_axi_transaction</span>. The master transaction class contains the constraints for master specific members in the base transaction class. At the end of each transaction, the master agent provides object of type <span class="Code">svt_axi_master_transaction</span> from its analysis ports, in active and passive mode.</div><div id="ww1121052" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>AXI Slave transaction (<span class="Code">svt_axi_slave_transaction</span>)</div><div id="ww1123915" class="L1Body"><span></span>The slave transaction class extends from the AXI transaction base class <span class="Code">svt_axi_transaction</span>. The slave transaction class contains the constraints for slave specific members in the base transaction class. At the end of each transaction, the slave agent provides object of type <span class="Code">svt_axi_slave_transaction</span> from its analysis ports, in active and passive mode.</div><div id="ww1121055" class="L1Body"><span></span>The master and slave transactions contain a handle to configuration object of type <span class="Code">svt_axi_port_configuration</span>, which provides the configuration of the port on which this transaction would be applied. The port configuration is used during randomizing the transaction. The port configuration is available in the sequencer of the master or slave agent. </div><div id="ww1123927" class="L1Body"><span></span>You should initialize the port configuration handle in the transaction using the port configuration available in the sequencer of the master or slave agent. If the port configuration handle in the transaction is null at the time of randomization, the transaction will issue a fatal message. </div><div id="ww1132957" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>AXI ACE Snoop Base transaction (<span class="Code">svt_axi_snoop_transaction</span>) </div><div id="ww1132958" class="L1Body"><span></span>This is the base class for snoop transaction type which contains all the physical attributes of the transaction like address, data, transaction type, etc. It also provides the timing information of the transaction to the master component, that is, delays for valid and ready signals with respect to some reference events. The <span class="Code">svt_axi_snoop_transaction</span> also contains a handle to configuration object of type <span class="Code">svt_axi_port_configuration</span>, which provides the configuration of the port on which this transaction would be applied. The port configuration is used during randomizing the transaction.</div><div id="ww1132960" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>AXI ACE Master Snoop transaction (<span class="Code">svt_axi_master_snoop_transaction</span>) </div><div id="ww1132961" class="L1Body"><span></span>The master snoop transaction class extends from the snoop transaction base class <span class="Code">svt_axi_snoop_transaction</span>. The master snoop transaction class contains the constraints for master specific members in the base transaction class. At the end of each transaction, the port monitor within the master VIP component provides object of type <span class="Code">svt_axi_master_snoop_transaction</span> from its analysis ports, in active and passive mode.</div><div id="ww1132963" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>AXI transaction on Interconnect Slave port (<span class="Code">svt_axi_ic_slave_transaction</span>)</div><div id="ww1132964" class="L1Body"><span></span><span class="Code">svt_axi_ic_slave_transaction</span> class is used by the slave ports of the Interconnect component, to represent the transaction received on the Interconnect slave port from a master component. At the end of each transaction on the Interconnect Slave port, the port monitor within the Interconnect slave port provides object of type <span class="Code">svt_axi_ic_slave_transaction</span> from its analysis port, in active and passive mode.</div><div id="ww1132967" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>AXI transaction on Interconnect Master port (<span class="Code">svt_axi_ic_master_transaction</span>)</div><div id="ww1132968" class="L1Body"><span></span><span class="Code">svt_axi_ic_master_transaction</span> class is used by the master ports of the Interconnect component, to represent the transaction transmitted on the interconnect master port to a connected slave component. At the end of each transaction on the Interconnect Master port, the port monitor within the Interconnect Master port provides object of type <span class="Code">svt_axi_ic_master_transaction</span> from its analysis port, in active and passive mode.</div><div id="ww1133764" class="L1Body"><span></span>This transaction class is not supported in this release. Currently, the port monitor within the Interconnect Master port provides object of type <span class="Code">svt_axi_master_transaction</span> from its analysis port.</div><div id="ww1132970" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>AXI ACE Snoop transaction on Interconnect Slave port (<span class="Code">svt_axi_ic_snoop_transaction</span>)</div><div id="ww1132971" class="L1Body"><span></span><span class="Code">svt_axi_ic_snoop_transaction</span> class extends from the snoop transaction base class <span class="Code">svt_axi_snoop_transaction</span>. This class represents the snoop transaction at the interconnect slave ports, which are connected to the external master components. At the end of each snoop transaction on the Interconnect Slave port, the port monitor within the Interconnect Slave port provides object of type <span class="Code">svt_axi_ic_snoop_transaction</span> from its analysis port, in active and passive mode.</div><div id="ww1123940" class="Body"><span></span>For more information on individual members of transaction classes, see the AXI VIP Class reference HTML documentation.</div><div id="ww1123933" class="H3">Analysis Ports</div><div id="ww1148284" class="Body"><span></span>The Port Monitor in the Master and Slave Agent provides <span class="Code">item_started_port</span> and <span class="Code">item_observed_port</span> analysis ports.</div><div id="ww1148287" class="Body"><span></span>The Master and Slave Agents respectively write the <span class="Code">svt_axi_master_transaction</span> and <span class="Code">svt_axi_slave_transaction</span> object to the <span class="Code">item_started_port</span> analysis port which provides AXI transactions available just when the transaction starts.</div><div id="ww1148289" class="Body"><span></span>At the end of the transaction, the Master and Slave Agents respectively write the completed</div><div id="ww1148290" class="Body"><span></span><span class="Code">svt_axi_master_transaction</span> and <span class="Code">svt_axi_slave_transaction</span> object to the <span class="Code">item_observed_port</span> analysis port. This holds true in active as well as passive mode of operation of the master or slave agent. You can use this analysis port for connecting to scoreboard, or any other purpose, where a transaction object for the completed transaction is required.</div><div id="ww1148294" class="Body"><span></span>The Port Monitor in the Interconnect Master Agent and Interconnect Slave agent also provides an analysis</div><div id="ww1148295" class="Body"><span></span>port <span class="Code">item_observed_port</span>. At the end of the transaction on the interconnect ports, the port monitor within the Interconnect Master Agent and Interconnect Slave agent provides the completed</div><div id="ww1148296" class="Body"><span></span><span class="Code">svt_axi_ic_master_transaction</span> and <span class="Code">svt_axi_ic_slave_transaction</span> object respectively, from its analysis port.</div><div id="ww1148298" class="Body"><span></span>Also you can create user-defined analysis ports for their scoreboarding purpose.</div><div id="ww1148300" class="BodyHead"><span></span>Usage:</div><div id="ww1148301" class="Body"><span></span>Steps to use <span class="Code">item_observed_port</span> analysis port in an UVM verification environment.</div><div id="ww1148302" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>Create an axi scoreboard class extending from uvm_scoreboard class and declare the export for the analysis port.</div><div id="ww1148303" class="L1Code">//The uvm_analysis_imp_decl allows for a scoreboard (or other analysis component) to</div><div id="ww1148304" class="L1Code">support input from many places</div><div id="ww1148305" class="L1Code">/** Macro that define two analysis ports with unique suffixes */</div><div id="ww1148306" class="L1Code">`uvm_analysis_imp_decl(_initiated)</div><div id="ww1148307" class="L1Code">`uvm_analysis_imp_decl(_response)</div><div id="ww1148308" class="L1Code">&nbsp;</div><div id="ww1148309" class="L1Code">class axi_uvm_scoreboard extends uvm_scoreboard;</div><div id="ww1148310" class="L1Code">  </div><div id="ww1148311" class="L1Code">  /** Analysis port connected to the AXI Master Agent */</div><div id="ww1148312" class="L1Code">  uvm_analysis_imp_initiated#(svt_axi_transaction, axi_uvm_scoreboard) item_observed_initiated_export;</div><div id="ww1148313" class="L1Code">&nbsp;</div><div id="ww1148314" class="L1Code">  /** Analysis port conneted to the AXI Slave Agent */</div><div id="ww1148315" class="L1Code">  uvm_analysis_imp_response#(svt_axi_transaction, axi_uvm_scoreboard) item_observed_response_export;</div><div id="ww1148316" class="L1Code">&nbsp;</div><div id="ww1148317" class="L1Code">&nbsp;</div><div id="ww1148318" class="L1Code">  /** UVM Component Utility macro */</div><div id="ww1148319" class="L1Code">  `uvm_component_utils(axi_uvm_scoreboard)</div><div id="ww1148320" class="L1Code">  </div><div id="ww1148321" class="L1Code">&nbsp;</div><div id="ww1148322" class="L1Code">&nbsp;</div><div id="ww1148323" class="L1Code">  function new (string name = "axi_uvm_scoreboard", uvm_component parent=null);</div><div id="ww1148324" class="L1Code">      super.new(name, parent);</div><div id="ww1148325" class="L1Code">  endfunction : new</div><div id="ww1148326" class="L1Code">  </div><div id="ww1148327" class="L1Code">endclass</div><div id="ww1148330" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>In the Scoreboard::<span class="Code">build()</span> phase, build export of analysis ports and create <span class="Code">write_***()</span> method to get the object from the analysis ports.</div><div id="ww1148332" class="L1Code">class axi_uvm_scoreboard extends uvm_scoreboard;</div><div id="ww1148333" class="L1Code">  ..</div><div id="ww1148334" class="L1Code">  ..</div><div id="ww1148335" class="L1Code">  function void build_phase(uvm_phase phase);</div><div id="ww1148336" class="L1Code">    super.build();</div><div id="ww1148337" class="L1Code">    /** Construct the analysis ports */</div><div id="ww1148338" class="L1Code">    item_observed_initiated_export = new("item_observed_initiated_export", this);</div><div id="ww1148339" class="L1Code">    item_observed_response_export = new("item_observed_response_export", this);</div><div id="ww1148340" class="L1Code">&nbsp;</div><div id="ww1148341" class="L1Code">  endfunction</div><div id="ww1148342" class="L1Code">endclass</div><div id="ww1148344" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>Create <span class="Code">write_***()</span> method to get the object from the <span class="Code">item_observed_port</span> analysis port class <span class="Code">axi_uvm_scoreboard</span> extends <span class="Code">uvm_scoreboard</span>;</div><div id="ww1148346" class="L1Code">  ..</div><div id="ww1148347" class="L1Code">  ..</div><div id="ww1148348" class="L1Code">&nbsp;</div><div id="ww1148349" class="L1Code">  /** This method is called by item_observed_initiated_export */ </div><div id="ww1148350" class="L1Code">  virtual function void write_initiated(input svt_axi_transaction xact);</div><div id="ww1148351" class="L1Code">    svt_axi_transaction init_xact;</div><div id="ww1148352" class="L1Code">&nbsp;</div><div id="ww1148353" class="L1Code">    if (!$cast(init_xact, xact.clone())) begin</div><div id="ww1148354" class="L1Code">      `uvm_fatal("write_initiated", "Unable to $cast the received transaction to svt_axi_transaction");</div><div id="ww1148355" class="L1Code">    end</div><div id="ww1148356" class="L1Code">   </div><div id="ww1148357" class="L1Code">    `uvm_info("write_initiated", $sformatf("xact:\n%s", init_xact.sprint()), UVM_FULL)</div><div id="ww1148358" class="L1Code">      </div><div id="ww1148359" class="L1Code">  endfunction</div><div id="ww1148360" class="L1Code">&nbsp;</div><div id="ww1148361" class="L1Code">  /** This method is called by item_observed_response_export */</div><div id="ww1148362" class="L1Code">  virtual function void write_response(input svt_axi_transaction xact);</div><div id="ww1148363" class="L1Code">    svt_axi_transaction  resp_xact;</div><div id="ww1148364" class="L1Code">&nbsp;</div><div id="ww1148365" class="L1Code">    if (!$cast(resp_xact, xact.clone())) begin</div><div id="ww1148366" class="L1Code">      `uvm_fatal("write_response", "Unable to $cast the received transaction to svt_axi_transaction");</div><div id="ww1148367" class="L1Code">    end</div><div id="ww1148368" class="L1Code">   </div><div id="ww1148369" class="L1Code">    `uvm_info("write_response", $sformatf("xact:\n%s", resp_xact.sprint()), UVM_FULL)</div><div id="ww1148370" class="L1Code">   </div><div id="ww1148371" class="L1Code">  endfunction</div><div id="ww1148372" class="L1Code">endclass</div><div id="ww1148375" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>4.	</span></span>In the ENV create an instance of the <span class="Code">axi_uvm_scoreboard</span> and build the object class <span class="Code">axi_env</span> extends <span class="Code">uvm_env</span>;</div><div id="ww1148377" class="L1Code">&nbsp;</div><div id="ww1148378" class="L1Code">  /** AXI System ENV */</div><div id="ww1148379" class="L1Code">  svt_axi_system_env axi_system_env;</div><div id="ww1148380" class="L1Code">  /** Master/Slave Scoreboard */</div><div id="ww1148381" class="L1Code">  axi_uvm_scoreboard axi_scoreboard;</div><div id="ww1148382" class="L1Code">&nbsp;</div><div id="ww1148383" class="L1Code">   /** UVM Component Utility macro */</div><div id="ww1148384" class="L1Code">  `uvm_component_utils(axi_env)</div><div id="ww1148385" class="L1Code">&nbsp;</div><div id="ww1148386" class="L1Code">  /** Class Constructor */</div><div id="ww1148387" class="L1Code">  function new (string name="axi_env", uvm_component parent=null);</div><div id="ww1148388" class="L1Code">    super.new (name, parent);</div><div id="ww1148389" class="L1Code">  endfunction</div><div id="ww1148390" class="L1Code">&nbsp;</div><div id="ww1148391" class="L1Code">  /** Build the AXI System ENV */</div><div id="ww1148392" class="L1Code">  virtual function void build_phase(uvm_phase phase);</div><div id="ww1148393" class="L1Code">    `uvm_info("build_phase", "Entered...",UVM_LOW)</div><div id="ww1148394" class="L1Code">&nbsp;</div><div id="ww1148395" class="L1Code">    super.build_phase(phase);</div><div id="ww1148396" class="L1Code">&nbsp;</div><div id="ww1148397" class="L1Code">    ..</div><div id="ww1148398" class="L1Code">    ..</div><div id="ww1148399" class="L1Code">    </div><div id="ww1148400" class="L1Code">    /* Create the scoreboard */</div><div id="ww1148401" class="L1Code">    axi_scoreboard = axi_uvm_scoreboard::type_id::create("axi_scoreboard", this);</div><div id="ww1148402" class="L1Code">    </div><div id="ww1148403" class="L1Code">    ..</div><div id="ww1148404" class="L1Code">    ..</div><div id="ww1148405" class="L1Code">&nbsp;</div><div id="ww1148406" class="L1Code">    `uvm_info("build_phase", "Exiting...", UVM_LOW)</div><div id="ww1148407" class="L1Code">  endfunction</div><div id="ww1148408" class="L1Code">endclass</div><div id="ww1148410" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>5.	</span></span>In the connect phase Connect master &amp; slave agent analysis ports to scoreboard</div><div id="ww1148411" class="L1Code">class axi_env extends uvm_env;</div><div id="ww1148412" class="L1Code">  ..</div><div id="ww1148413" class="L1Code">  ..</div><div id="ww1148414" class="L1Code">  function void connect_phase(uvm_phase phase);</div><div id="ww1148415" class="L1Code">    `uvm_info("connect_phase", "Entered...",UVM_LOW)</div><div id="ww1148416" class="L1Code">&nbsp;</div><div id="ww1148417" class="L1Code">    /**</div><div id="ww1148418" class="L1Code">     * Connect the master and slave agent's analysis ports with</div><div id="ww1148419" class="L1Code">     * item_observed_before_export and item_observed_after_export ports of the</div><div id="ww1148420" class="L1Code">     * scoreboard.</div><div id="ww1148421" class="L1Code">     */</div><div id="ww1148422" class="L1Code">        axi_system_env.master[0].monitor.item_observed_port.connect(axi_scoreboard.item_observed_initiated_export);</div><div id="ww1148423" class="L1Code">    axi_system_env.slave[0].monitor.item_observed_port.connect(axi_scoreboard.item_observed_response_export);</div><div id="ww1148424" class="L1Code">    endfunction</div><div id="ww1148425" class="L1Code">endclass</div><div id="ww1148427" class="Body"><span></span>For complete example, see the <span class="Code">tb_axi_svt_uvm_intermediate_sys</span> example testbench.</div><div id="ww1148430" class="Body"><span></span><span style="font-weight: bold">Example</span>: How do I add user-defined TLM analysis ports into Port Monitor callbacks in an UVM environment?</div><div id="ww1148431" class="Body" style="color: #0000ff; font-style: normal; font-variant: normal; font-weight: normal; text-transform: none; vertical-align: baseline"><span></span><span class="Link"><a href="https://solvnet.synopsys.com/retrieve/037331.html" target="external_window">https://SolvNetPlus.synopsys.com/retrieve/037331.html</a></span></div><div id="ww1119525" class="H3">Callbacks</div><div id="ww1119543" class="Body"><span></span>Callbacks are an access mechanism that enable the insertion of user-defined code and allow access to objects for scoreboarding and functional coverage. Each Master and Slave Agent is associated with a callback class that contains a set of callback methods. These methods are called as part of the normal flow of procedural code. There are a few differences between callback methods and other methods that set them apart.</div><div id="ww1119545" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Callbacks are virtual methods with no code initially, so they do not provide any functionality unless they are extended. The exception to this rule is that some of the callback methods for functional coverage already contain a default implementation of a coverage model.</div><div id="ww1119546" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>The callback class is accessible to you so the class can be extended and your code inserted, potentially including testbench specific extensions of the default callback methods, and testbench specific variables and/or methods used to control whatever behavior the testbench is using the callbacks to support.</div><div id="ww1119547" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Callbacks are called within the sequential flow at places where external access would be useful. In addition, the arguments to the methods include references to relevant data objects. For example, just before a monitor puts a transaction object into an analysis port is a good place to sample for functional coverage since the object reflects the activity that just happened on the pins. A callback at this point with an argument referencing the transaction object allows this exact scenario.</div><div id="ww1122034" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>There is no need to invoke callback methods for callbacks that are not extended. To avoid a loss of performance, callbacks are not executed by default. To execute callback methods, callback class must be registered with the component using <span class="Code">uvm_register_cb</span> macro.</div><div id="ww1119549" class="Body"><span></span>AXI VIP uses callbacks in three main applications:</div><div id="ww1119550" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Access for functional coverage</div><div id="ww1119551" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Access for scoreboarding</div><div id="ww1119552" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Insertion of user-defined code</div><div id="ww1119560" class="H4">Master Agent Callbacks</div><div id="ww1122041" class="Body"><span></span>In the Master Agent, the callback methods are called by Master Driver and Port Monitor components. </div><div id="ww1123995" class="Body"><span></span>The following callback classes which contain the callback methods are invoked by the Master Agent:</div><div id="ww1123996" class="L1Bul" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">svt_axi_master_callback</span></div><div id="ww1123997" class="L1Bul" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">svt_axi_port_monitor_callback</span></div><div id="ww1123998" class="Body"><span></span>For more information on these classes, see the class reference HTML documentation.</div><div id="ww1148806" class="Body"><span></span>The following is the list of callback methods available from <span class="Code">svt_axi_master_callback</span> class:</div><div id="ww1148808" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void <span class="Code">associate_xact_to_barrier_pair</span> (<span class="Code">svt_axi_master</span> <span class="Code">axi_master</span> , <span class="Code">svt_axi_master_transaction</span> <span class="Code">xact</span>, <span class="Code">svt_axi_barrier_pair_transaction</span> <span class="Code">barrier_pair_xact [$]</span>)</div><div id="ww1148809" class="L1Body"><span></span>Callback issued by master transactor when barrier transactions are enabled and when '<span class="Code">associate_barrier_xact</span>' bit is set to 1 in the <span class="Code">svt_axi_master_transaction</span> class</div><div id="ww1148811" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void <span class="Code">input_port_cov</span> (svt_axi_master axi_master , svt_axi_transaction xact )</div><div id="ww1148812" class="L1Body"><span></span>Callback issued to allow the testbench to collect functional coverage information from a transaction received at the input channel which is connected to the generator.</div><div id="ww1148814" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void <span class="Code">post_input_port_get</span> ( svt_axi_master axi_master , svt_axi_transaction xact , ref bit drop)</div><div id="ww1148815" class="L1Body"><span></span>Called after the master transactor gets a transaction from the input TLM port.</div><div id="ww1148817" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void <span class="Code">post_snoop_input_port_get</span> (svt_axi_master axi_master , svt_axi_master_snoop_transaction xact, ref bit drop)</div><div id="ww1148818" class="L1Body"><span></span>Callback issued by master transactor after pulling the snoop response from the snoop response generator</div><div id="ww1148820" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void <span class="Code">pre_address_phase_started</span> (svt_axi_master axi_master , svt_axi_transaction xact)</div><div id="ww1148821" class="L1Body"><span></span>Called just before driving the address phase of a transaction.</div><div id="ww1148823" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void <span class="Code">pre_cache_update</span> (svt_axi_master axi_master , svt_axi_master_transaction xact )</div><div id="ww1148824" class="L1Body"><span></span>Callback issued by master transactor just before updating the data into the cache.</div><div id="ww1148826" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void <span class="Code">pre_snoop_data_phase_started</span> ( svt_axi_master axi_master , svt_axi_master_snoop_transaction xact)</div><div id="ww1148827" class="L1Body"><span></span>Callback issued just before driving the data phase of a snoop transaction.</div><div id="ww1148829" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void <span class="Code">pre_snoop_resp_phase_started</span> (svt_axi_master axi_master , svt_axi_master_snoop_transaction xact)</div><div id="ww1148830" class="L1Body"><span></span>Callback issued just before driving response to a snoop transaction.</div><div id="ww1148832" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void <span class="Code">pre_write_data_phase_started</span> (svt_axi_master axi_master , svt_axi_transaction xact)</div><div id="ww1148833" class="L1Body"><span></span>Called just before driving a data beat of a write transaction</div><div id="ww1148835" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void <span class="Code">snoop_input_port_cov</span> (svt_axi_master axi_master , svt_axi_master_snoop_transaction xact)</div><div id="ww1148836" class="L1Body"><span></span>Callback issued to allow the testbench to collect functional coverage information from a snoop transaction received at the input port of the master transactor, which is connected to the snoop response generator.</div><div id="ww1148838" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">svt_axi_master_callback</span> methods arguments description:</div><div id="ww1148840" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span><span class="Code">axi_master</span> - A reference to the svt_axi_master component that is issuing this callback. The user's callback implementation can use this to access the public data and/or methods of the component.</div><div id="ww1148842" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span><span class="Code">xact</span> - A reference to the transaction descriptor object of interest.</div><div id="ww1148844" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span><span class="Code">drop</span> - A ref argument, which if set by the user's callback implementation causes the transactor to discard the transaction descriptor without further action.</div><div id="ww1119802" class="H4">Slave Agent Callbacks</div><div id="ww1122266" class="Body"><span></span>In the Slave Agent, the callback methods are called by Slave Driver and port monitor components. </div><div id="ww1124040" class="Body"><span></span>The following callback classes which contain the callback methods are invoked by the Slave Agent:</div><div id="ww1124041" class="L1Bul" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">svt_axi_slave_callback</span></div><div id="ww1124042" class="L1Bul" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">svt_axi_port_monitor_callback</span></div><div id="ww1124061" class="Body"><span></span>For more information of these classes, see the class reference HTML documentation.</div><div id="ww1149054" class="Body"><span></span>The following is the list of callback methods available from <span class="Code">svt_axi_slave_callback</span> class:</div><div id="ww1149056" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void <span class="Code">input_port_cov</span> (svt_axi_slave axi_slave , svt_axi_transaction xact )</div><div id="ww1149057" class="L1Body"><span></span>	Callback issued to allow the testbench to collect functional coverage information from a transaction received the input channel which is connected to the generator.</div><div id="ww1149059" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void  <span class="Code">post_input_port_get</span> ( svt_axi_slave axi_slave , svt_axi_transaction xact , ref bit drop )</div><div id="ww1149060" class="L1Body"><span></span>	Called after the slave transactor gets a slave response transaction from the slave response generator.</div><div id="ww1149062" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void  <span class="Code">pre_read_data_phase_started</span> ( svt_axi_slave axi_slave , svt_axi_transaction xact )</div><div id="ww1149063" class="L1Body"><span></span>	Called just before driving the read data phase of a read transaction.</div><div id="ww1149065" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void  <span class="Code">pre_write_resp_phase_started</span> ( svt_axi_slave axi_slave , svt_axi_transaction xact )</div><div id="ww1149066" class="L1Body"><span></span>	Called just before driving a write response phase of a write transaction.</div><div id="ww1149069" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>svt_axi_slave_callback method arguments description:</div><div id="ww1149071" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span><span class="Code">axi_slave</span> - A reference to the <span class="Code">svt_axi_slave</span> component that is issuing this callback. The user's callback implementation can use this to access the public data and/or methods of the component.</div><div id="ww1149073" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span><span class="Code">xact</span> - A reference to the transaction descriptor object of interest.</div><div id="ww1149075" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span><span class="Code">drop</span> - A ref argument, which if set by the user's callback implementation causes the transactor to discard the transaction descriptor without further action.</div><div id="ww1149188" class="Body"><span></span>The following is the list of callback methods available from <span class="Code">svt_axi_port_monitor_callback</span> class:</div><div id="ww1149190" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	new_snoop_transaction_started ( svt_axi_port_monitor axi_monitor , svt_axi_snoop_transaction item )</div><div id="ww1149191" class="L1Body"><span></span>	Called when a new snoop transaction is observed on the port.</div><div id="ww1149193" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	new_transaction_started ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149194" class="L1Body"><span></span>	Called when a new transaction is observed on the port.</div><div id="ww1149196" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	pre_output_port_put ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149197" class="L1Body"><span></span>Called before putting a transaction to the analysis port. Extension of this method in the default coverage callback class is used for triggering transaction coverage.</div><div id="ww1149199" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	pre_response_request_port_put ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149200" class="L1Body"><span></span>	Called just before the response request transaction is provided by slave port monitor to slave response generator.</div><div id="ww1149202" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	pre_snoop_output_port_put ( svt_axi_port_monitor axi_monitor , svt_axi_snoop_transaction item )</div><div id="ww1149203" class="L1Body"><span></span>	Called before putting a snoop transaction to the analysis port.</div><div id="ww1149205" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	pre_tlm_generic_payload_port_put ( svt_axi_port_monitor axi_monitor , uvm_tlm_generic_payload xact )</div><div id="ww1149206" class="L1Body"><span></span>	Called when a transaction completes and when use_tlm_gp_sequencer is set in the port configuration. The completed AXI transaction is converted to a PV-annotated TLM GP and is made available through this callback.</div><div id="ww1149208" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	pre_tlm_generic_payload_snoop_port_put ( svt_axi_port_monitor axi_monitor , uvm_tlm_generic_payload xact )</div><div id="ww1149209" class="L1Body"><span></span>	Called when a snoop transaction completes and when use_tlm_gp_sequencer is set in the port configuration. The completed AXI snoop response is converted to a PV-annotated TLM GP and is made available through this callback.</div><div id="ww1149211" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	read_address_phase_ended ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149212" class="L1Body"><span></span>	Called when read address handshake is complete, that is, when ARVALID and ARREADY are asserted. Extension of this method in the default coverage callback class is used for signal coverage of read address channel signals.</div><div id="ww1149214" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	read_address_phase_started ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149215" class="L1Code">	Called when ARVALID is asserted.</div><div id="ww1149217" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	read_data_phase_ended ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149218" class="L1Body"><span></span>	Called when read data handshake is complete, that is, when RVALID and RREADY are asserted. Extension of this method in the default coverage callback class is used for signal coverage of read data channel signals.</div><div id="ww1149220" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	read_data_phase_started ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149221" class="L1Body"><span></span>	Called when RVALID is asserted.</div><div id="ww1149223" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	snoop_address_phase_ended ( svt_axi_port_monitor axi_monitor , svt_axi_snoop_transaction item )</div><div id="ww1149224" class="L1Body"><span></span>	Called when snoop address handshake is complete, that is, when ACVALID and ACREADY are asserted.</div><div id="ww1149226" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	snoop_address_phase_started ( svt_axi_port_monitor axi_monitor , svt_axi_snoop_transaction item )</div><div id="ww1149227" class="L1Body"><span></span>	Called when ACVALID is asserted.</div><div id="ww1149229" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	snoop_data_phase_ended ( svt_axi_port_monitor axi_monitor , svt_axi_snoop_transaction item )</div><div id="ww1149230" class="L1Body"><span></span>	Called when snoop data handshake is complete, that is, when CDVALID and CDREADY are asserted.</div><div id="ww1149232" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	snoop_data_phase_started ( svt_axi_port_monitor axi_monitor , svt_axi_snoop_transaction item )</div><div id="ww1149233" class="L1Body"><span></span>	Called when CDVALID is asserted.</div><div id="ww1149235" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	snoop_resp_phase_ended ( svt_axi_port_monitor axi_monitor , svt_axi_snoop_transaction item )</div><div id="ww1149236" class="L1Body"><span></span>	Called when snoop response handshake is complete, that is, when CRVALID and CRREADY are asserted.</div><div id="ww1149238" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	snoop_resp_phase_started ( svt_axi_port_monitor axi_monitor , svt_axi_snoop_transaction item )</div><div id="ww1149239" class="L1Body"><span></span>	Called when CRVALID is asserted.</div><div id="ww1149241" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	stream_transfer_ended ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149242" class="L1Body"><span></span>	Called when stream handshake is complete, that is, when TVALID and TREADY are asserted. </div><div id="ww1149244" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	stream_transfer_started ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149245" class="L1Body"><span></span>	Called when TVALID is asserted.</div><div id="ww1149247" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	transaction_ended ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149248" class="L1Body"><span></span>	Called when a transaction ends.</div><div id="ww1149250" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	write_address_phase_ended ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149251" class="L1Body"><span></span>	Called when write address handshake is complete, that is, when AWVALID and AWREADY are asserted. Extension of this method in the default coverage callback class is used for signal coverage of write address channel signals.</div><div id="ww1149253" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	write_address_phase_started ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149254" class="L1Body"><span></span>	Called when AWVALID is asserted.</div><div id="ww1149256" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	write_data_phase_ended ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149257" class="L1Body"><span></span>	Called when write data handshake is complete, that is, when WVALID and WREADY are asserted. Extension of this method in the default coverage callback class is used for signal coverage of write data channel signals.</div><div id="ww1149259" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	write_data_phase_started ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149260" class="L1Body"><span></span>	Called when WVALID is asserted.</div><div id="ww1149262" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	write_resp_phase_ended ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149263" class="L1Body"><span></span>	Called when write response handshake is complete, that is, when BVALID and BREADY are asserted. Extension of this method in the default coverage callback class is used for signal coverage of write response channel signals.</div><div id="ww1149265" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	write_resp_phase_started ( svt_axi_port_monitor axi_monitor , svt_axi_transaction item )</div><div id="ww1149266" class="L1Body"><span></span>	Called when BVALID is asserted.</div><div id="ww1149268" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>svt_axi_port_monitor_callback method arguments description:</div><div id="ww1149270" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>axi_monitor - A reference to the svt_axi_port_monitor component that is issuing this callback. The user's callback implementation can use this to access the public data and/or methods of the component.</div><div id="ww1149272" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>item - A reference to the transaction descriptor object of interest.</div><div id="ww1132351" class="H4">Interconnect Env Callbacks</div><div id="ww1132382" class="Body"><span></span>In the Interconnect Env, callback methods are called by the master and slave ports. </div><div id="ww1132396" class="Body"><span></span>The following callback class contains the Interconnect Env callback method:</div><div id="ww1132383" class="L1Bul" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">svt_axi_interconnect_callback</span></div><div id="ww1132374" class="Body"><span></span>For more information of these classes, see the class reference HTML documentation. </div><div id="ww1149508" class="Body"><span></span>The following is the list of callback methods available from <span class="Code">svt_axi_interconnect_callback</span> class:</div><div id="ww1149510" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void post_input_port_get(svt_axi_interconnect axi_interconnect, svt_axi_ic_slave_transaction xact)</div><div id="ww1149511" class="L1Body"><span></span>Callback issued just after receiving a coherent transaction.</div><div id="ww1149513" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void post_slave_xact_gen(svt_axi_interconnect axi_interconnect, svt_axi_master_transaction xact)</div><div id="ww1149514" class="L1Body"><span></span>Callback issued after the interconnect randomizes a transaction to be routed to a slave.</div><div id="ww1149516" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void pre_output_port_put ( svt_axi_interconnect axi_interconnect , svt_axi_ic_slave_transaction xact )</div><div id="ww1149517" class="L1Body"><span></span>Callback issued after the interconnect receives all responses from snooped ports and before driving coherent response to corresponding port.</div><div id="ww1149520" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>svt_axi_interconnect_callback method arguments description:</div><div id="ww1149522" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>axi_interconnect - A reference to the svt_axi_interconnect component that is issuing this callback. The user's callback implementation can use this to access the public data and/or methods of the component.</div><div id="ww1149524" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>xact - A reference to the transaction descriptor object of interest.</div><div id="ww1149629" class="H4">System Monitor Callbacks</div><div id="ww1149630" class="Body"><span></span>System Monitor provides hooks in the form of callbacks, which can be used to perform such design specific checks. The following callback class contains the System Monitor callback method:</div><div id="ww1149631" class="Body" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span></span><span class="Code">svt_axi_system_monitor_callback</span></div><div id="ww1159452" class="Body"><span></span>Refer to AXI Class Reference HTML documentation for the specific callback methods of this callback class.</div><div id="ww1149633" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	interconnect_generated_dirty_data_write_detected ( svt_axi_system_monitor system_monitor , svt_axi_system_transaction sys_xact , svt_axi_transaction slave_xact )</div><div id="ww1149634" class="L1Body"><span></span>	Called after the system monitor detects that a write transaction initiated by the interconnect corresponds to a write of dirty data returned by a snoop transaction.</div><div id="ww1149636" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	master_xact_fully_associated_to_slave_xacts ( svt_axi_system_monitor system_monitor , svt_axi_system_transaction sys_xact )</div><div id="ww1149637" class="L1Body"><span></span>	Called after the system monitor correlates all the bytes of a master transaction to corresponding slave transactions.</div><div id="ww1149639" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	new_master_transaction_received ( svt_axi_system_monitor system_monitor , svt_axi_transaction xact )</div><div id="ww1149640" class="L1Body"><span></span>	Called when a new transaction initiated by a master is observed on the port.</div><div id="ww1149642" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	new_slave_transaction_received ( svt_axi_system_monitor system_monitor , svt_axi_transaction xact )</div><div id="ww1149643" class="L1Body"><span></span>	Called when a new transaction initiated by an interconnect to a slave is observed on the port.</div><div id="ww1149645" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	new_snoop_transaction_received ( svt_axi_system_monitor system_monitor , svt_axi_snoop_transaction xact )</div><div id="ww1149646" class="L1Body"><span></span>	Called when a new snoop transaction initiated by an interconnect is observed on the port.</div><div id="ww1149648" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	new_system_transaction_started ( svt_axi_system_monitor system_monitor , svt_axi_system_transaction sys_xact , svt_axi_transaction xact )</div><div id="ww1149649" class="L1Body"><span></span>	Called when a new overlapped transaction initiated by a master is observed on the port.</div><div id="ww1149651" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	post_coherent_and_snoop_transaction_association ( svt_axi_system_monitor system_monitor , svt_axi_transaction coherent_xact , svt_axi_snoop_transaction snoop_xacts [$] )</div><div id="ww1149652" class="L1Body"><span></span>	Called after the system monitor associates snoop transactions to a coherent transaction.</div><div id="ww1149654" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>virtual function void 	pre_check_execute ( svt_axi_system_monitor system_monitor , svt_err_check_stats check , svt_axi_transaction xact , ref bit execute_check )</div><div id="ww1149655" class="L1Body"><span></span>	Called before a check is executed by the system monitor. Currently supported only for data_integrity_check.</div><div id="ww1149657" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>svt_axi_system_monitor_callback method arguments description:</div><div id="ww1149659" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>system_monitor - A reference to the svt_axi_system_monitor component that is issuing this callback. The user's callback implementation can use this to access the public data and/or methods of the component.</div><div id="ww1149661" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>sys_xact - A reference to the system transaction descriptor object of interest.</div><div id="ww1149663" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>slave_xact - A reference to the slave transaction descriptor object which was detected as a dirty data write.</div><div id="ww1149665" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>xact - A reference to the data descriptor object of interest.</div><div id="ww1149667" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>coherent_xact - A reference to the coherent data descriptor object of interest.</div><div id="ww1149669" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>snoop_xacts - A queue of all associated snoop transactions.</div><div id="ww1149671" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>check - A reference to the check that will be executed</div><div id="ww1149673" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>execute_check - A bit that indicates if the check must be performed.</div><div id="ww1149676" class="Body"><span></span><span style="font-weight: bold">Usage</span>:</div><div id="ww1149677" class="Body"><span></span>Steps to implement callbacks feature in an UVM verification environment.</div><div id="ww1149678" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>Create a user-defined callback class that extends from the AXI VIP callback class.</div><div id="ww1149680" class="L1Body"><span></span>class axiPortMonitorCallbacks extends svt_axi_port_monitor_callback;</div><div id="ww1149682" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>Implement the required callback method in this extended class. </div><div id="ww1149683" class="L1Code">virtual function void  new_transaction_started (svt_axi_port_monitor axi_monitor, svt_axi_transaction item);</div><div id="ww1149684" class="L1Code">    $display("Inside new_transaction_started Port Monitor Callback");</div><div id="ww1149685" class="L1Code">    item.print(); </div><div id="ww1149686" class="L1Code">endfunction</div><div id="ww1149688" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>Declare an instance of the user defined callback class (Example: In your env).</div><div id="ww1149689" class="L1Code">class axiEnv extends uvm_env;</div><div id="ww1149690" class="L1Code">  axiPortMonitorCallbacks monitor_cb;</div><div id="ww1149691" class="L1Code">  ..</div><div id="ww1149692" class="L1Code">  ..</div><div id="ww1149693" class="L1Code">endclass</div><div id="ww1149695" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>4.	</span></span>Register the callback with the appropriate component in either connect_phase or start_of_simulation_phase.</div><div id="ww1149696" class="L1Code">class axiEnv extends uvm_env;</div><div id="ww1149697" class="L1Code">  ..</div><div id="ww1149698" class="L1Code">  ..</div><div id="ww1149699" class="L1Code">  function void start_of_simulation();</div><div id="ww1149700" class="L1Code">    super.start_of_simulation_phase(phase);</div><div id="ww1149701" class="L1Code">    monitor_cb = new( "monitor_cb" ); //create object of callback class</div><div id="ww1149702" class="L1Code">    uvm_callback#(svt_axi_port_monitor,svt_axi_port_monitor_callback)::add(</div><div id="ww1149703" class="L1Code">	axi_system_env.master[0].monitor, monitor_cb);</div><div id="ww1149704" class="L1Code">         //Registering the callback with AXI Master VIP's monitor. </div><div id="ww1149705" class="L1Code">     //The master monitor type and the master monitor callback type are provided as    parameters to uvm_callbacks class. </div><div id="ww1149706" class="L1Code">     //The add method takes the actual instance of the AXI master monitor and the callback object.</div><div id="ww1149707" class="L1Code">  endfunction</div><div id="ww1149708" class="L1Code">endclass</div><div id="ww1149764" class="BodyHead"><span></span>Example: Usage of AXI port monitor callback to get count of outstanding transactions with AXI SVT VIP slave component</div><div id="ww1149765" class="Body"><span></span>(SolvNetPlus: <span class="Link"><a href="https://solvnet.synopsys.com/retrieve/040575.html" target="external_window">https://SolvNetPlus.synopsys.com/retrieve/040575.html</a></span>)</div><div id="ww1120001" class="H3">Interfaces and Modports</div><div id="ww1121114" class="Body"><span></span>SystemVerilog models signal connections using interfaces and modports. Interfaces define the set of signals which make up a port connection. Modports define collection of signals for a given port, the direction of the signals, and the clock with respect to which these signals are driven and sampled.</div><div id="ww1124085" class="Body"><span></span>AXI VIP provides the SystemVerilog interface which can be used to connect the VIP to the DUT. A top-level interface<span class="Code"> svt_axi_if</span> is defined. The top-level interface contains an array of Master port sub-interfaces of type <span class="Code">svt_axi_master_if</span>, and Slave port sub-interfaces of type <span class="Code">svt_axi_slave_if</span>. </div><div id="ww1124086" class="Body"><span></span>The top-level interface is contained in the system configuration class. The top-level interface is specified to the system configuration class using method <span class="Code">svt_axi_system_configuration::set_if</span>. </div><div id="ww1137939" class="Body"><span></span>Alternatively, the interface can also be specified to the AXI System Env component directly through UVM Configuration database. For more details on usage, see AXI Basic example <span class="Code">tb_axi_svt_uvm_basic_sys.</span> </div><div id="ww1132412" class="Body"><span></span>If the AXI System Env is used, then it first retrieves the configuration using the config db. It then attempts to retrieve the virtual interface using the config db. If a virtual interface is supplied through the config db, then the AXI System Env will update the configuration with it (a warning will be generated if the configuration object already has a virtual interface reference). The AXI System Env then passes the configuration object down to the master and slave agents. If the virtual interface is not supplied through the config db, then a fatal error is generated if the virtual interface is not valid in the configuration. </div><div id="ww1137521" class="Body"><span></span>Otherwise the virtual interface in configuration is used without modification. When the System Env has a configuration object with a valid virtual interface, then all the sub-objects receive the interface from the configuration object. </div><div id="ww1126812" class="Body"><span></span>If the Master or Slave Agent is used as standalone, then the process is the same. These classes will continue to receive the configuration object using the config db. In addition, they will retrieve the virtual interface from the config db and perform the same checks done in the AXI System Env to ensure that a valid configuration object is created that contains a virtual interface reference.</div><div id="ww1135642" class="Body"><span></span>For more information on AXI Interface, see the <span class="Code">$DESIGNWARE_HOME/vip/svt/amba_svt/latest/doc/class_ref/axi_svt_uvm_class_reference/html/interfaces.html</span></div><div id="ww1124122" class="H4">Modports</div><div id="ww1124123" class="Body"><span></span>The port interface <span class="Code">svt_axi_master_if</span> contains following modports which you should use to connect VIP to the DUT:</div><div id="ww1124124" class="L1Bul" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">svt_axi_slave_modport</span></div><div id="ww1138152" class="L1Body"><span></span>This modport is used to connect master VIP component to slave DUT port.</div><div id="ww1126384" class="L1Bul" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">svt_axi_debug_modport</span></div><div id="ww1138162" class="L1Body"><span></span>This modport can be used by you to access the debug port signals. For information on debug port, see the <span class="Link"><a href="../axi_svt_uvm_user_guide/07_Troubleshooting.12.2.html#ww1117860" title="Using Debug Port">“Using Debug Port”</a></span>.</div><div id="ww1126391" class="Body"><span></span>The port interface <span class="Code">svt_axi_slave_if</span> contains the following modports which you should use to connect VIP to the DUT:</div><div id="ww1124127" class="L1Bul" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">svt_axi_master_modport</span></div><div id="ww1138172" class="L1Body"><span></span>This modport is used to connect slave VIP component to master DUT port.</div><div id="ww1124128" class="L1Bul" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">svt_axi_debug_modport</span></div><div id="ww1138182" class="L1Body"><span></span>This modport can be used by you to access the debug port signals. See <span class="Link"><a href="../axi_svt_uvm_user_guide/07_Troubleshooting.12.2.html#ww1117860" title="Using Debug Port">“Using Debug Port”</a></span> for details on debug port.</div><div id="ww1136961" class="H4">Clocking Modes</div><div id="ww1124358" class="Body"><span></span>The interface works in the following two clocking modes:</div><div id="ww1124359" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Common clock mode</div><div id="ww1124133" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Multiple clock mode </div><div id="ww1124224" class="Body"><span></span>The clock mode can be selected using configuration parameter, <span class="Code">svt_axi_system_configuration::common_clock_mode</span>. When set to one, the signal <span class="Code">common_aclk</span> in the top interface will be used to drive clock of all port sub-interfaces. In this case, the system clock in the environment will need to be connected to <span class="Code">common_aclk</span> signal in the top interface. </div><div id="ww1138192" class="Body"><span></span>When this configuration parameter is set to 0, the aclk signal of each port sub-interface would need to be connected to appropriate clock in the environment.</div><div id="ww1138201" class="H5"><span class="WebWorks_Number" style="width: 76.536pt"><span>3.3.7.2.1	</span></span>Common Clock Mode</div><div id="ww1124226" class="Body"><span></span>In this mode,</div><div id="ww1124138" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>All port sub-interfaces will operate on a single common clock.</div><div id="ww1124139" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>You need to connect system clock to the <span class="Code">common_aclk</span> signal in the top interface.</div><div id="ww1124140" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Top-level interface will pass the common clock signal down to all port sub-interfaces.</div><div id="ww1124141" class="H5"><span class="WebWorks_Number" style="width: 76.536pt"><span>3.3.7.2.2	</span></span>Multiple Clock Mode</div><div id="ww1124142" class="Body"><span></span>In this mode, each port interface would operate on a separate port interface clock. In this case, aclk signal in the port interface needs to be connected to the appropriate clock in the environment.</div><div id="ww1137951" class="H4">Bind Interfaces</div><div id="ww1137088" class="Body"><span></span>AXI VIP also supports bind interfaces for master &amp; slave. Bind interface is an interface which contains directional signals for AXI. You can connect DUT signals to these directional signals. Bind interfaces provided with VIP are <span class="Code">svt_axi_master_bind_if</span> and <span class="Code">svt_axi_slave_bind_if</span>. To use bind interface, you must instantiate the non-bind interface, and then connect the bind interface to the non-bind interface. VIP provides master and slave connector modules to connect the VIP bind interface to the VIP non-bind interface. You must instantiate a connector module corresponding to each instance of VIP master and slave, and pass the bind interface and non-bind interface instance to this connector module.</div><div id="ww1137089" class="Body"><span></span>For more information on the usage of bind interface, see the AXI intermediate example.</div><div id="ww1137157" class="H4">Parameterized Interfaces</div><div id="ww1137175" class="Body"><span></span>AXI VIP supports parameterized interfaces <span class="Code">svt_axi_master_param_if</span> and <span class="Code">svt_axi_slave_param_if</span>. These interfaces are parameterized for signal widths. The default value of all the parameters are same as the system constants defined in <span class="Code">svt_axi_port_defines.svi </span>(see <span class="Link"><a href="../axi_svt_uvm_user_guide/03_DataObjects.03.04.html#ww1124151" title="AXI UVM User Interface">Step&nbsp;3.3.9</a></span>). These interface parameters can be changed to match the DUT signal widths. The parameter value should be less than or equal to the system constant defined in <span class="Code">svt_axi_port_defines.svi</span> or <span class="Code">svt_axi_user_defines.svi</span>. </div><div id="ww1137343" class="Body"><span></span>To use parameterized interface, the user still needs to instantiate the top-level interface <span class="Code">svt_axi_if</span>. The <span class="Code">svt_axi_master_param_if</span> interface should be used for connecting AXI Master VIP component to the DUT and <span class="Code">svt_axi_slave_param_if</span> interface should be used to connect AXI Slave VIP component to the DUT.</div><div id="ww1137344" class="Body"><span></span>For usage of parameterized interface, see the <span class="Code">tb_axi_svt_uvm_basic_param_if_sys</span> example. The README file in the example describes the usage.</div><div id="ww1150899" class="H3">Transaction Status Tracking Methods and Events </div><div id="ww1150900" class="Body"><span></span>Transaction status tracking methods provides information on the status of the data transfer at the interface. Different methods and events that you can make use of are as follows:</div><div id="ww1152000" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Link"><a href="../axi_svt_uvm_user_guide/03_DataObjects.03.04.html#ww1150901" title="AXI UVM User Interface">Transaction Class Status Attributes</a></span></div><div id="ww1152002" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Link"><a href="../axi_svt_uvm_user_guide/03_DataObjects.03.04.html#ww1150902" title="AXI UVM User Interface">Transaction Class Methods</a></span></div><div id="ww1151994" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Link"><a href="../axi_svt_uvm_user_guide/03_DataObjects.03.04.html#ww1150903" title="AXI UVM User Interface">Events</a></span></div><div id="ww1150901" class="H4">Transaction Class Status Attributes</div><div id="ww1151488" class="Body"><span></span>Transaction class status attributes indicate status of transactions based on valid and ready signals of the axi interface. The status attributes are addr_status, data_status, and write_resp_status for address phase, data phase, and write response phase respectively. The status indicator strings are INITIAL, ACTIVE, ACCEPT, PARTIAL _ACCEPT and ABORTED. HTML Class reference document provides detailed description on status strings and transaction status flow.</div><div id="ww1151489" class="Body"><span></span>You can track the transaction flow through transaction object by referring these status indicator strings. This is helpful for transaction tracking in the log file. </div><div id="ww1151490" class="BodyHead"><span></span> INITIAL</div><div id="ww1151491" class="Body"><span></span>Status is considered as INITIAL when valid and ready are both LOW on the channel</div><div id="ww1151492" class="Body"><span></span>Example: <span class="Code">Read addr_status</span> at INITIAL state is shown as follows:</div><div class="ww_skin_page_overflow"><div id="ww1151539" class="Body"><span></span><img class="Default" src="../axi_svt_uvm_user_guide/images/Transaction_class_attributes.png" width="100%" style="display: block; left: 0.0pt; max-height: 72px; max-width: 621px; top: 0.0pt" alt="" title="" /></div></div><div id="ww1151580" class="Body"><span></span>The status indicates that master has not driven an address at the interface</div><div id="ww1151581" class="BodyHead"><span></span>ACTIVE</div><div id="ww1151582" class="Body"><span></span>The Status is considered as ACTIVE when valid signal is HIGH with ready signal at LOW. If the VIP agent is driving a transaction, (that is, Active VIP Agents) the status will be set to ACTIVE when it asserts valid signal   whereas if the VIP Agent is monitoring the transfer, (for example, Passive VIP Agents) the status will be set to ACTIVE at the event of sampling valid signal. </div><div class="ww_skin_page_overflow"><div id="ww1151583" class="Body"><span></span>Example: Read <span class="Code">addr_status</span> status changing to ACTIVE is illustrated as follows:<img class="Default" src="../axi_svt_uvm_user_guide/images/Transaction_class_attributes2.png" width="100%" style="display: block; left: 0.0pt; max-height: 91px; max-width: 633px; top: 0.0pt" alt="" title="" /></div></div><div id="ww1151696" class="Body"><span></span>The status indicates that master has driven an address and is not yet accepted by the slave</div><div id="ww1151697" class="BodyHead"><span></span>ACCEPT</div><div id="ww1151698" class="Body"><span></span>Status is considered as ACCEPT when the channel handshake is complete, that is when both ready and valid are both HIGH. </div><div class="ww_skin_page_overflow"><div id="ww1151699" class="Body"><span></span>Example: Read <span class="Code">addr_status</span> changing to ACCEPT is shown as follows:<img class="Default" src="../axi_svt_uvm_user_guide/images/Transaction_class_attributes3.png" width="100%" style="display: block; left: 0.0pt; max-height: 86px; max-width: 630px; top: 0.0pt" alt="" title="" /></div></div><div id="ww1151766" class="Body"><span></span>The status indicates that the slave has accepted the address with awvalid-awready handshake </div><div id="ww1151767" class="BodyHead"><span></span>PARTIAL_ACCEPT</div><div id="ww1151768" class="Body"><span></span>PARTIAL_ACCEPT status is applicable on read/write data channels incase of multi-beat or burst transfer. In case of multi-beat transfer, the transfer is complete only when the last beat data is transferred. Status is considered as PARTIAL_ACCEPT when a beat is completed with hand shake but the last beat data is not transferred. For example, In case of an INCR4 write, for beat 1-3, when wvalid and wready are both HIGH then the status is   PARTIAL_ACCEPT. The figure shows write <span class="Code">data_status</span> as PARTIAL_ACCEPT.</div><div class="ww_skin_page_overflow"><div id="ww1151813" class="Body"><span></span><img class="Default" src="../axi_svt_uvm_user_guide/images/Transaction_class_attributes4.png" width="100%" style="display: block; left: 0.0pt; max-height: 103px; max-width: 627px; top: 0.0pt" alt="" title="" /></div></div><div id="ww1151817" class="Body"><span></span>wlast at LOW indicate that the write data beats are not complete.</div><div id="ww1151818" class="BodyHead"><span></span>ABORTED</div><div id="ww1151819" class="Body"><span></span>The status is considered as ABORTED when a transfer is canceled. This happens in case of a mid-simulation reset.</div><div id="ww1150902" class="H4">Transaction Class Methods</div><div id="ww1151841" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">get_begin_time()</span>: This method gives starting time of a transaction.</div><div id="ww1151842" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">get_end_time()</span>: This method gives end time of a transaction. </div><div id="ww1151843" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">wait_for_transaction_end()</span>: This method waits for the transaction to end. In case of read transfer, the transaction ends when read response is complete with read response handshake. </div><div id="ww1152656" class="Body"><span></span>Similarly, for write, the transaction ends when the write response handshake is complete. </div><div id="ww1150903" class="H4">Events </div><div id="ww1151877" class="Body"><span></span>VIP components issue transaction begin_event and end_event. These events are provided by the uvm library and they denote the start of transaction and end of transaction. These events are issued by the Master and Slave components as described below, in both active and passive mode.</div><div id="ww1151879" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">begin_event</span>: For WRITE transactions, begin_event is issued on the rising clock edge when awvalid (for address before data) or wvalid (for data before address) is high. For READ transactions, begin_event is issued on the rising clock edge when arvalid is high.</div><div id="ww1152827" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">end_event</span>: For WRITE transactions, the end_event is issued on the rising clock edge when bvalid and bready both are high. For READ transactions, the end_event is issued on the rising clock edge when rvalid, rlast and rready are high.</div><div id="ww1124151" class="H3">Overriding System Constants</div><div id="ww1124152" class="Body"><span></span>The VIP uses include files to define system constants that, in some cases, you may override so the VIP matches your expectations. For example, you can override the maximum delay values. You can also adjust the default simulation footprint, like maximum address width.</div><div id="ww1124153" class="Body"><span></span>The system constants for the VIP are specified (or referenced) in the following files (the first three files reside at <span class="Code">$DESIGNWARE_HOME/vip/svt/amba_svt/latest/sverilog/include</span>):</div><div id="ww1138224" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>svt_axi_defines.svi</div><div id="ww1138234" class="L1Body"><span></span>Top-level include file. It allows for the inclusion of the common define symbols and the port define symbols in a single file. Also, it contains a `<span class="Code">include</span> to read user overrides if the <span class="Code">`SVT_AXI_INCLUDE_USER_DEFINES</span> symbol is defined.</div><div id="ww1138246" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>svt_axi_common_defines.svi</div><div id="ww1138256" class="L1Body"><span></span>This file defines common constants used by the AXI VIP components. You can override only the <span class="Code">User Definable</span> constants, which are declared in <span class="Code">ifndef</span> statements, such as the following:</div><div id="ww1124156" class="L1Body" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span></span><span class="Code">`ifndef SVT_AXI_MAX_ADDR_VALID_DELAY</span></div><div id="ww1124157" class="L1Body" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span></span><span class="Code"> `define SVT_AXI_MAX_ADDR_VALID_DELAY 16</span></div><div id="ww1124158" class="L1Body" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span></span><span class="Code">`endif</span></div><div id="ww1124159" class="L1Bul" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">svt_axi_port_defines.svi</span></div><div id="ww1138274" class="L1Body"><span></span>This file contains the constants that set the default maximum footprint of the environment. These values determine the wire bit widths in the 'wire frame'-- they do not (necessarily) define the actual bit widths used by the components, which is determined by the configuration classes.</div><div id="ww1124160" class="L1Bul" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span><span class="Code">svt_axi_user_defines.svi</span></div><div id="ww1138287" class="L1Body"><span></span>This file contains override values that you define. This file can reside anywhere-- specify its location on the simulator command line.</div><div id="ww1138297" class="Body"><span></span>To override the<span class="Code"> SVT_AXI_MAX_ID_WIDTH</span> constant from the <span class="Code">svt_axi_port_defines.svi</span> file,</div><div id="ww1124162" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Redefine the corresponding symbol in the <span class="Code">svt_axi_user_defines.svi</span> file. For example:</div><div id="ww1124163" class="L1Body" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span></span><span class="Code">`define SVT_AXI_MAX_ID_WIDTH 12</span></div><div id="ww1124280" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>In the simulator compile command,</div><div id="ww1124281" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>Ensure that the directory containing <span class="Code">svt_axi_user_defines.svi</span> is provided to the simulator</div><div id="ww1124282" class="L2Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L2Bul.png" alt="*" border="0" width="11" height="11" /></span></span>Provide <span class="Code">SVT_AXI_INCLUDE_USER_DEFINES</span> on the simulator command line as follows: </div><div id="ww1124299" class="L2Body" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; margin-bottom: 4.0pt; margin-top: 4.0pt; text-transform: none; vertical-align: baseline"><span></span><span class="Code">+define+SVT_AXI_INCLUDE_USER_DEFINES</span></div><div id="ww1124300" class="Body"><span></span>Note the following restrictions when overriding the default maximum footprint: </div><div id="ww1124301" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Do not use a value of 0 for a <span class="Code">MAX_*_WDTH</span> value. The value must be &gt;= 1</div><div id="ww1124171" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>The maximum footprint set at compile time must work for the full design. If you are using multiple instances of AXI VIP, only one maximum footprint can be set and must therefore satisfy the largest requirement. </div><div id="ww1126898" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>The value of less than 32 is not supported for <span class="Code">SVT_AXI_MAX_ADDR_WIDTH</span>. <span class="Code">SVT_AXI_MAX_ADDR_WIDTH</span> only defines the footprint of address port. The actual used address with is defined by <span class="Code">svt_axi_port_configuration::addr_width</span>, which can still be configured to less than 32.</div><div id="ww1140342" class="H3">Support for TLM Generic Payload</div><div id="ww1140360" class="Body"><span></span>The AXI VIP supports TLM Generic Payload feature where the user can develop sequences based on the uvm_tlm_generic_payload transaction type. The AXI VIP then maps these Generic Payload sequences into AXI specific sequences.</div><div id="ww1140417" class="Body"><span></span>&nbsp;</div><div class="ww_skin_page_overflow"><table class="Note" style="width: 540.75024pt" cellspacing="0" summary=""><tr><td style="padding-bottom: 6pt; padding-left: 6pt; padding-right: 10pt; padding-top: 6pt; vertical-align: top; width: 77.99976pt"><div id="ww1166822" class="Z_Note"><span><img src="Note.gif" alt="*" border="0" width="100" height="27" /></span>&nbsp;</div></td><td style="padding-bottom: 6pt; padding-left: 6pt; padding-right: 10pt; padding-top: 6pt; vertical-align: top; width: 462.75048pt"><div id="ww1166824" class="TableBody"><span></span>This feature is supported for UVM flow only, for interface types AXI3 and AXI4. Also, TLM Generic Payload feature does not yet map TLM Generic Payload transactions to AXI transactions with burst length greater than 16.</div></td></tr></table></div><div id="ww1140352" class="H4">Generating TLM Generic Payload Stimulus</div><div id="ww1141160" class="Body"><span></span>By default, AXI stimulus is generated using svt_axi_master_transaction sequence items in the AXI master agent sequencer. The bus-agnostic stimulus can be generated using uvm_tlm_generic_payload sequence items.</div><div id="ww1140609" class="Body"><span></span>You can enable this functionality by setting the svt_axi_port_configuration::use_tlm_generic_payload to '1' for the corresponding AXI master before that master's build_phase is executed.</div><div id="ww1141424" class="Code">function void my_env::build_phase(uvm_phase phase);</div><div id="ww1141425" class="Code">   super.build_phase(phase);</div><div id="ww1141426" class="Code">&nbsp;</div><div id="ww1141427" class="Code">   cfg.master_cfg[1].use_tlm_generic_payload = 1;</div><div id="ww1141428" class="Code">   uvm_config_db#(svt_axi_system_configuration)::set(this,</div><div id="ww1141429" class="Code">                                                     "axi_env",</div><div id="ww1141430" class="Code">                                                     "cfg", cfg);</div><div id="ww1141431" class="Code">   axi_env = axi_system_env::type_id::create("axi_env", this);</div><div id="ww1141432" class="Code">endfunction</div><div id="ww1141466" class="Code">&nbsp;</div><div id="ww1141482" class="Body"><span></span>Enabling this functionality causes the instantiation of svt_axi_tlm_generic_payload_sequencer in the svt_axi_master_agent::tlm_generic_payload_sequencer property and the execution of a layering sequence on the AXI transaction sequencer. The layering sequence pulls generated TLM generic payload sequence items from the generic payload sequencer, maps them to one or more AXI master transactions, and executes them on the driver. The layering sequence executes with a normal priority. It is still possible to execute normal AXI transaction sequences on the AXI transaction sequencer, in parallel with the TLM generic payload layering sequence.</div><div id="ww1141483" class="Body"><span></span>The response from the execution of the generic payload item is annotated in the generic payload sequence item itelf. It is valid only when the completed generic payload sequence item is returned by the uvm_sequence::get_response() method.</div><div id="ww1141467" class="Body"><span></span>&nbsp;</div><div id="ww1141501" class="Code">class my_gp_seq extends uvm_sequence#(uvm_tlm_generic_payload);</div><div id="ww1141502" class="Code">   ...</div><div id="ww1141503" class="Code">   task body();</div><div id="ww1141504" class="Code">      `uvm_create(req);</div><div id="ww1141505" class="Code">      req.set_command(UVM_TLM_READ_COMMAND);</div><div id="ww1141506" class="Code">      req.set_address('h123456789);</div><div id="ww1141507" class="Code">      req.set_length(64);</div><div id="ww1141508" class="Code">      `uvm_send(req);</div><div id="ww1141509" class="Code">      get_response(rsp);</div><div id="ww1141510" class="Code">      if (rsp.is_response_ok()) begin</div><div id="ww1141511" class="Code">         // gp.m_data[] is now valid</div><div id="ww1141512" class="Code">      end</div><div id="ww1141513" class="Code">   endtask</div><div id="ww1141514" class="Code">endclass</div><div id="ww1140635" class="Body"><span></span>The TLM generic payload sequence items are mapped into one or more AXI transactions that implement the semantics of the Generic Payload transaction, as defined by the TLM 2.0 standard. It is not possible to generate all possible AXI master transactions from generic payload stimulus.</div><div id="ww1140636" class="Body"><span></span>&nbsp;</div><div class="ww_skin_page_overflow"><table class="Note" style="width: 540.75024pt" cellspacing="0" summary=""><tr><td style="padding-bottom: 6pt; padding-left: 6pt; padding-right: 10pt; padding-top: 6pt; vertical-align: top; width: 77.99976pt"><div id="ww1166857" class="Z_Note"><span><img src="Note.gif" alt="*" border="0" width="100" height="27" /></span>&nbsp;</div></td><td style="padding-bottom: 6pt; padding-left: 6pt; padding-right: 10pt; padding-top: 6pt; vertical-align: top; width: 462.75048pt"><div id="ww1166859" class="TableBody"><span></span>For demonstration of the usage, see the ts.tlm_generic_payload_test.sv test present in the tb_axi_svt_uvm_intermediate_sys example.</div></td></tr></table></div><div id="ww1140637" class="Body"><span></span>By default, generic payload WRITE and READ commands are mapped to WRITENOSNP and READNOSNP AXI transactions respectively, with a maximum 16-beat INCR burst and individual transfer size matching the configured port size. In case different AXI transactions are required, the generic payload sequence item must be annotated with an instance of the svt_amba_pv_extension generic payload AMBA PV (Programmer's View) extension.</div><div id="ww1141532" class="Code">class my_gp_seq extends uvm_sequence#(uvm_tlm_generic_payload);</div><div id="ww1141533" class="Code">   ...</div><div id="ww1141534" class="Code">   task body();</div><div id="ww1141535" class="Code">      svt_amba_pv_extension   pv;</div><div id="ww1141536" class="Code">&nbsp;</div><div id="ww1141537" class="Code">      `uvm_create(req);</div><div id="ww1141538" class="Code">      pv = new("pv");</div><div id="ww1141539" class="Code">      req.set_extension(pv);</div><div id="ww1141540" class="Code">      ...</div><div id="ww1141541" class="Code">      pv.set_size(1);</div><div id="ww1141542" class="Code">      pv.set_length(64);</div><div id="ww1141543" class="Code">      pv.set_burst(svt_axi_transaction::WRAP);</div><div id="ww1141544" class="Code">&nbsp;</div><div id="ww1141545" class="Code">      `uvm_send(gp);</div><div id="ww1141546" class="Code">   endtask</div><div id="ww1141547" class="Code">endclass</div><div id="ww1140654" class="Body"><span></span>The various attributes of the AMBA PV extension can be set to specify the characteristics of the AXI transaction(s) used to implement the annotated generic payload transaction. Should the annotation be present, it will be further annotated with the relevant response from the execution of the AXI transactions. The relevant response will be annotated within the member svt_amba_pv_extension::m_response of svt_amba_pv_response type.</div><div id="ww1140655" class="Body"><span></span>&nbsp;</div><div class="ww_skin_page_overflow"><table class="Note" style="width: 540.75024pt" cellspacing="0" summary=""><tr><td style="padding-bottom: 6pt; padding-left: 6pt; padding-right: 10pt; padding-top: 6pt; vertical-align: top; width: 77.99976pt"><div id="ww1166892" class="Z_Note"><span><img src="Note.gif" alt="*" border="0" width="100" height="27" /></span>&nbsp;</div></td><td style="padding-bottom: 6pt; padding-left: 6pt; padding-right: 10pt; padding-top: 6pt; vertical-align: top; width: 462.75048pt"><div id="ww1166894" class="TableBody"><span></span>For details of svt_amba_pv_extension, see AXI UVM Class Reference HTML. See ts.amba_pv_test.sv test present in tb_axi_svt_uvm_intermediate_sys example for demonstration of the usage.</div></td></tr></table></div><div id="ww1141216" class="H4">Connecting a TLM 2.0 Master</div><div id="ww1141232" class="Body"><span></span>By default, TLM generic payload stimulus is generated using  SystemVerilog sequences in the AXI master agent generic payload sequencer. If the TLM generic payload transactions are created by an ARM FastModel or a TLM Master model written in SystemC/SystemVerilog, it is possible to connect the AXI master agent to a TLM master. AXI Master agent component in the AMBA VIP provides required sockets for connecting to the TLM master.</div><div id="ww1141233" class="Body"><span></span>Should the TLM Master be implemented in SystemC, you will need to connect the socket on the Master to the socket on the VIP using UVMConnect or VCS/TLI and convert the AMBA PV SystemC transactions to equivalent AMBA PV SystemVerilog transactions.</div><div id="ww1141234" class="Body"><span></span>You can enable this functionality by setting the svt_axi_port_configuration::use_pv_socket to '1' for the corresponding AXI master before that master's build_phase is executed.</div><div id="ww1142101" class="Code">function void my_env::build_phase(uvm_phase phase);</div><div id="ww1142102" class="Code">   super.build_phase(phase);</div><div id="ww1142103" class="Code">&nbsp;</div><div id="ww1141267" class="Code">   cfg.master_cfg[1].use_pv_socket = 1;</div><div id="ww1141268" class="Code">   </div><div id="ww1141305" class="Code">&nbsp;&nbsp;&nbsp;uvm_config_db#(svt_axi_system_configuration)::set(this,</div><div id="ww1141269" class="Code">                                                     "axi_env",</div><div id="ww1141270" class="Code">                                                     "cfg", cfg);</div><div id="ww1141271" class="Code">   axi_env = axi_system_env::type_id::create("axi_env", this);</div><div id="ww1141272" class="Code">endfunction</div><div id="ww1140668" class="Body"><span></span>Enabling this functionality implies the enabling of TLM generic payload stimulus (see Section <span class="Link"><a href="../axi_svt_uvm_user_guide/03_DataObjects.03.04.html#ww1140352" title="AXI UVM User Interface">3.3.10.1</a></span>).</div><div id="ww1140670" class="Body"><span></span>Enabling this functionality causes the instantiation of an uvm_tlm_b_target_socket interface in the svt_axi_master_agent::b_fwd property and an uvm_tlm_b_initiator_socket interface in the svt_axi_master_agent::b_snoop property. Furthermore, the default run_phase sequence for the ACE snoop response sequencer is replaced with a reactive sequence which forwards all ACE snoop transaction requests (translated to equivalent uvm_tlm_generic_payload transactions annotated with a svt_amba_pv_extension) to the backward svt_axi_master_agent::b_snoop interface to be fulfilled by the coherent TLM master. The coherent TLM master must provide the snoop response by providing the relevant cache line content in the data member of the uvm_tlm_generic_payload and status information in the relevant fields of the attached svt_amba_pv_extension. </div><div id="ww1141324" class="Body"><span></span>In case the TLM master is not coherent, the AXI master agent can be re-configured to handle ACE snoop requests natively using its local cache model. The following is an example code snippet that can be used for this purpose:</div><div id="ww1141332" class="Code">uvm_config_db#(uvm_object_wrapper)::set("axi_env.master[2]",</div><div id="ww1141333" class="Code">   "snoop_sequencer.run_phase", "default_sequence",</div><div id="ww1141334" class="Code">   svt_axi_ace_master_snoop_response_sequence::type_id::get());</div><div id="ww1141378" class="Code">&nbsp;</div><div id="ww1140674" class="Body"><span></span>For demonstration of the usage for AXI3/4, see the <span class="Code">ts.amba_pv_test.sv</span> test within the <span class="Code">tb_axi_svt_uvm_intermediate_sys</span> example . For demonstration of the usage for ACE, see <span class="Code">tb_axi_svt_uvm_ace_sys</span> example.</div><div id="ww1141785" class="H4">Connecting a TLM 2.0 Slave</div><div id="ww1141786" class="Body"><span></span>As Reactive agent, the sequence <span class="Code">svt_axi_slave_tlm_response_sequence</span> in AXI Slave agent sequencer translates slave transactions into corresponding AMBA-PV extended TLM Generic Payload Transactions. This is applicable for TLM generic payload transactions created by an ARM.</div><div id="ww1141788" class="Body"><span></span>FastModel or a TLM Slave model written in SystemC or SystemVerilog, connects the AXI Slave agent to a TLM Slave. The AMBA VIP provides the sockets required for connecting to the TLM slave in the AXI Slave agent component.</div><div id="ww1142298" class="Body"><span></span>When the TLM Slave is implemented in SystemC, you will need to connect the socket on the Slave to the socket on the VIP using UVM Connect or VCS/TLI and convert AMBA PV SystemVerilog transactions to AMBA PV SystemC transactions.</div><div id="ww1142299" class="Body"><span></span>&nbsp;</div><div class="ww_skin_page_overflow"><table class="Note" style="width: 540.75024pt" cellspacing="0" summary=""><tr><td style="padding-bottom: 6pt; padding-left: 6pt; padding-right: 10pt; padding-top: 6pt; vertical-align: top; width: 77.99976pt"><div id="ww1166927" class="Z_Note"><span><img src="Note.gif" alt="*" border="0" width="100" height="27" /></span>&nbsp;</div></td><td style="padding-bottom: 6pt; padding-left: 6pt; padding-right: 10pt; padding-top: 6pt; vertical-align: top; width: 462.75048pt"><div id="ww1166929" class="TableBody"><span></span>Support for TLM GP in the AXI slave is through sockets. Therefore, the configuration attribute <span class="Code">svt_axi_port_configuration::use_pv_socket</span> must be set to '1' to enable TLM GP at the slave for the corresponding AXI Slave before that slave's <span class="Code">build_phase</span> is executed.</div></td></tr></table></div><div id="ww1142300" class="Code"><span class="Code">function void my_env::build_phase(uvm_phase phase);</span></div><div id="ww1142093" class="Code"><span class="Code">	super.build_phase(phase);</span></div><div id="ww1142109" class="Code">&nbsp;</div><div id="ww1141796" class="Code"><span class="Code">	cfg.slave_cfg[1].use_pv_socket = 1;</span></div><div id="ww1142113" class="Code">&nbsp;</div><div id="ww1141797" class="Code"><span class="Code">	uvm_config_db#(svt_axi_system_configuration)::set(this,</span></div><div id="ww1142167" class="Code"><span class="Code">																		"axi_env",</span></div><div id="ww1141799" class="Code"><span class="Code">																		"cfg", cfg);</span></div><div id="ww1141800" class="Code"><span class="Code">	axi_env = axi_system_env::type_id::create("axi_env", this);</span></div><div id="ww1142258" class="Code"><span class="Code">Endfunction</span></div><div id="ww1142266" class="Body"><span></span>Enabling this functionality causes the instantiation of an <span class="Code">uvm_tlm_b_initiator_socket </span>interface in the <span class="Code">svt_axi_slave_agent::resp_socket</span> property. </div><div id="ww1142260" class="Body"><span></span>For demonstration of the usage of AXI3 or AXI4, see <span class="Code">ts.amba_pv_test.sv</span> test within the <span class="Code">tb_axi_svt_uvm_intermediate_sys </span>example.</div><noscript><div id="noscript_warning">This site works best with JavaScript enabled</div></noscript><footer><!-- Related Topics --><!--                --><!-- Disqus --><!--        --><!-- Google Translation --><!--                    --><br /></footer><input type="hidden" id="preserve_unknown_file_links" value="false"></input></body></html>