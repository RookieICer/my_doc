<!DOCTYPE HTML >
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AXI SVT UVM  Documentation - Sequence Class List</title>
<link href="svdoc.css" rel="stylesheet" type="text/css">
<link href="svdoctabs.css" rel="stylesheet" type="text/css">
<script src="GeneralUtility.js"></script>
<script src="PCFiltering.js"></script>
<script>
    (function(){
        var searchJsLoadStatus = '';
        var pendingSearch = false;
        window._SearchFunction = function() {
            if (searchJsLoadStatus === 'complete') {
                pendingSearch = false;
                var searchForm = document.getElementById('builtin-search');
                SearchFunction(searchForm.searchtext.value, '', searchForm.searchmode.value);
            }
            else if (searchJsLoadStatus === 'in-progress'){
                pendingSearch = true;
            }
            else {
                pendingSearch = true;
                loadSearchJs();
            }
        }
        window.loadSearchJs = function() {
            function onSearchJsLoad() {
                searchJsLoadStatus = 'complete';
                if (pendingSearch) {
                    _SearchFunction();
                }
            }
            if (!searchJsLoadStatus) {
                searchJsLoadStatus = 'in-progress';
                var scriptElem = document.createElement('script');
                scriptElem.type = 'text/javascript';
                scriptElem.src = 'advancedsearch.js';
                scriptElem.onreadystatechange = onSearchJsLoad;
                scriptElem.onload = onSearchJsLoad;
                document.head.appendChild(scriptElem);
            }
        }
    })();
</script>
</head><body>
<!-- Generated by svdoc V-2023.09-2 -->
<div class='smartsearch-info'>  <div class='smartsearch-info-content'>    <div class='smartsearch-info-header'>      <h1 class='smartsearch-info-title'>VIP Smartsearch</h1>      <span class='smartsearch-info-close'>X</span>    </div>    <div class='smartsearch-info-body'>      <ul style='list-style: none; padding-left: 1em'>        <li>          <span>VIP Smartsearch is a framework that supports search within VIP reference documents using query in natural language. It facilitates reordering of search results and keeps record of userâ€™s decision for the ordering of result display and applies that in search of same query on subsequent usage.</span>        </li>        <li>          <p class='smartsearch-info-question'>How to download VIP smartsearch?</p>          <ol type='i'>            <li>Get VIP Smartsearch <span style='font-size: 0.9em;'>(Available as a seperate run file).</span></li>            <li>Set environment variable <pre>DESIGNWARE_HOME</pre> to required designware home location where VIP Smartsearch should be downloaded.</li>            <li>              Run <pre>vip_smartsearch_&lt;version&gt;.run</pre> file.<br>              VIP Smartsearch will be downloaded to the location <pre>$DESIGNWARE_HOME/vip/svt/vip_smartsearch/&lt;version&gt;</pre>            </li>          </ol>        </li>        <li>          <p class='smartsearch-info-question'>How to install VIP Smartsearch?</p>          <span>Please refer to the file</span> <pre>VIP_Smartsearch_installation_and_usage_guide.pdf</pre> in <pre>$DESIGNWARE_HOME/vip/svt/vip_smartsearch/&lt;version&gt;</pre> <span>for installation steps.</span>        </li>        <li>          <p class='smartsearch-info-question'>Customer Support</p>          For more details about VIP smartsearch tool, contact support_center@synopsys.com.<br>          Mention your queries along with below details and send email to above email id.<br>          Product: Verification IP<br>          Sub Product: &lt;vip_title&gt;<br>          Tool: VIP Smartsearch<br>        </li>      </ul>    </div>    <div class='smartsearch-info-footer'> 16 November 2023, Copyright &copy; 2023 Synopsys, Inc. </div>  </div></div><div class="tabs"><ul>
  <li><a href="index.html" TITLE = "About this product"><span>Main&nbsp;Page</span></a></li>
  <li id="current"><a href="Configuration_class_list.html" TITLE = "List of all classes"><span>Classes</span></a></li>
  <li><a href="macros.html" TITLE = "Alphabetical listing of macros"><span>Macros</span></a></li>
  <li><a href="level1_covergroups.html" TITLE = "Coverage"><span>Coverage</span></a></li>
  <li><a href="protocolChecks.html" TITLE = "List of Protocol Checks defined in VIP"><span>Protocol&nbsp;Checks</span></a></li>
  <li><a href="sequencepages.html" TITLE = "List of Sequences"><span>Sequences</span></a></li>
  <li><a href="interfaces.html" TITLE = "List of Interfaces"><span>Interfaces</span></a></li>
  <li><a href="ports.html" TITLE = "List of Ports"><span>Ports</span></a></li>
  <li><a href="globals.html" TITLE = "Global members"><span>Globals</span></a></li>
  <li><a href="indexall.html" TITLE = "Complete Index of all Source Code Elements"><span>Index</span></a></li>
  <li><a href="svtbcl.html" TITLE = "SVT Base Class Library"><span>SVT&nbsp;BCL</span></a></li>
  <li><a href="help.html" TITLE = "Help"><span>?</span></a></li>
  <li><form id='builtin-search' action='javascript:_SearchFunction()'>    <table border="0"><tr>
<td><a class='smartsearch-btn'>Smartsearch</a></td>
    <td><input NAME="searchbtn" TYPE=button VALUE=" Search " onChange='_SearchFunction()'></td>
    <td><input NAME="searchtext" TYPE=text VALUE="" onclick='loadSearchJs();' onChange='_SearchFunction()'></td>
    <td><select NAME="searchmode" TYPE=text >
          <option value=simple>simple</option>
          <option value=regexpr>reg expr</option>
    </select></td>
  </tr></table></form>  <script>      window.parent.postMessage('builtin-search-loaded', '*');  </script></li>
</ul></div>
<div class="tabs"><ul>
  <li><a href="Configuration_class_list.html" TITLE = ""><span>Configurations</span></a></li>
  <li><a href="Agent_class_list.html" TITLE = ""><span>Agents</span></a></li>
  <li><a href="Driver_class_list.html" TITLE = ""><span>Drivers</span></a></li>
  <li><a href="Env_class_list.html" TITLE = ""><span>Env</span></a></li>
  <li><a href="Monitor_class_list.html" TITLE = ""><span>Monitor</span></a></li>
  <li><a href="Sequencer_class_list.html" TITLE = ""><span>Sequencer</span></a></li>
  <li><a href="Transaction_class_list.html" TITLE = ""><span>Transaction</span></a></li>
  <li id="current"><a href="Sequence_class_list.html" TITLE = ""><span>Sequences</span></a></li>
  <li><a href="Coverage_class_list.html" TITLE = ""><span>Coverage</span></a></li>
  <li><a href="Callback_class_list.html" TITLE = ""><span>Callbacks</span></a></li>
  <li><a href="Status_class_list.html" TITLE = ""><span>Status</span></a></li>
  <li><a href="Exception_class_list.html" TITLE = ""><span>Exceptions</span></a></li>
  <li><a href="Other_class_list.html" TITLE = ""><span>Others</span></a></li>
</ul></div>
<h1>AXI SVT UVM  Documentation - Sequence Class List</h1>Here are the Sequence classes with brief descriptions:
<table>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_write_same_id_device_non_bufferable_memory_diff_masters_response_ictest_sequence.html">svt_axi_ordering_write_same_id_device_non_bufferable_memory_diff_masters_response_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master M0 VIP to drive multiple write transactions with same ID.<br>
 #- Simultaneously program the Master M1 VIP to drive multiple write transactions<br>
 with same ID and it should be equal to ID used by M0.<br>
 #- Program the Slave VIP to respond out-of-order.<br>
 #- Program the Slave VIP to respond with OKAY for transactions addressed by M0 and<br>
 SLVERR for transactions addressed by M1. The transactions coming from M0 and M1<br>
 can be differentiated based on address.<br>
 #- Check the BRESP forwarded by interconnect to M0 are OKAY and for M1 are SLVERR.<br>
 This check will be performed within the virtual sequence running on AXI System<br>
 Sequencer.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi3_ordering_write_diff_id_no_interleave_at_slave_ictest_sequence.html">svt_axi3_ordering_write_diff_id_no_interleave_at_slave_ictest_sequence</a></td>
  <td class="compvalue">#- Configure Master VIP to interleaving depth >1.<br>
 #- Program AXI3 Master VIP to drive a sequence of write transactions with write<br> 
 data interleaving.<br>
 #- Configure the AXI3 Slave VIP to interleaving depth of 1<br>
 #- Check that the Interconnect is forwarding the transactions to the AXI3 Slave<br> 
 VIP without write data interleaving<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi3_ordering_write_diff_id_interleave_with_repeating_id_ictest_sequence.html">svt_axi3_ordering_write_diff_id_interleave_with_repeating_id_ictest_sequence</a></td>
  <td class="compvalue">#- Program all AXI3 Master VIPs to simultaneously drive a sequence of write<br> 
 transactions with repeating AWID's (1,2,1,2,1). In case of master being<br> 
 configured as AXI3 write data with interleaving (with write interleaving<br> 
 depth >1).Transaction address will be randomly selected based on system<br> 
 address map.<br>
 #- Configure the AXI3 Slave VIP interleaving depth >1.<br>
 #- Check that the Interconnect is forwarding the correct write data with<br> 
 respect to address issued.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi3_ordering_write_diff_id_interleave_ictest_sequence.html">svt_axi3_ordering_write_diff_id_interleave_ictest_sequence</a></td>
  <td class="compvalue">#- Program all AXI3 Master VIPs to simultaneously drive a sequence of write<br> 
 transactions with interleaved write data(with write interleaving depth >1 )<br>
 with random AWID's. <br>
 Transaction address will be randomly selected based on system address map.<br>
 #- Configure the AXI3 Slave VIP interleaving depth >1.<br>
 #- Check that the Interconnect is forwarding the correct write data with respect<br>
 to address issued<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_write_same_id_from_diff_masters_ictest_sequence.html">svt_axi_ordering_write_same_id_from_diff_masters_ictest_sequence</a></td>
  <td class="compvalue">#- Program a randomly selected Master M0 VIP to drive a write transaction to<br> 
 the Slave VIP .<br>
 #- Program the Slave VIP to suspend the response of write transaction from<br> 
 Master M0 VIP.<br>
 Use <a class="ClassLink" href="./transaction/class_svt_axi_transaction.html">svt_axi_transaction</a> <b>::</b> <a class="ClassLink" href="./transaction/class_svt_axi_transaction.html#item_suspend_response">suspend_response</a> member to suspend the response.<br>
 Use it in slave response sequence.<br>
 #- Program another randomly selected Master M1 VIP to drive a write transaction<br>
 to the same Slave VIP.Wait for transaction from M1 to end.<br>
 #- Release the suspended response from Slave VIP for write transaction from Master<br>
 M0 VIP.<br>
    . </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_read_same_id_from_diff_masters_ictest_sequence.html">svt_axi_ordering_read_same_id_from_diff_masters_ictest_sequence</a></td>
  <td class="compvalue">#- Program a randomly selected Master M0 VIP to drive a read transaction<br> 
 to the Slave VIP .<br>
 #- Program the Slave VIP to suspend the response of read transaction from Master<br>
 M0 VIP.Use <a class="ClassLink" href="./transaction/class_svt_axi_transaction.html">svt_axi_transaction</a> <b>::</b> <a class="ClassLink" href="./transaction/class_svt_axi_transaction.html#item_suspend_response">suspend_response</a> member to suspend the response.<br>
 Use it in slave response sequence.<br>
 #- Program another randomly selected Master M1 VIP to drive a read transaction to<br> 
 the same Slave VIP.Wait for transaction from M1 to end.<br>
 #- Release the suspended response from Slave VIP for read transaction from Master<br> 
 M0 VIP.<br>
    . </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_write_read_same_id_ictest_sequence.html">svt_axi_ordering_write_read_same_id_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive write transaction.<br>
 #- After few clock cycles, program the Master VIP to drive read transaction to<br> 
 Slave VIP with ARID same as AWID.<br>
 #- Program the Slave VIP to delay the response of previous write transaction.<br>
 #- Check interconnect forwards the response of read transaction and then response<br> 
 of write transaction.This will get tested through system configuration<br>
 bus_inactivity_timeout.<br>
    . </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_read_write_same_id_ictest_sequence.html">svt_axi_ordering_read_write_same_id_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive read transaction.<br>
 #- After few clock cycles, program the Master VIP to drive write transaction<br> 
 to Slave VIP with AWID same as ARID.<br>
 #- Program the Slave VIP to delay the response of previous read transaction.<br>
 #- Check interconnect forwards the response of write transaction and then response<br>
 of read transaction.<br>
    . </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_write_read_without_wait_ictest_sequence.html">svt_axi_ordering_write_read_without_wait_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive write transaction to Slave VIP.<br>
 #- Program the Slave VIP to delay the response of previous write transaction<br> 
 until further intimation.<br>
 #- Program the Master VIP to drive read transaction to the same Slave VIP before<br>
 getting response to above write transaction.<br>
 #- Check that the Interconnect is forwarding the read transaction before receiving<br>
 response from Slave VIP.This will get tested through system configuration<br>
 bus_inactivity_timeout.<br>
 #- Program the Slave VIP to respond to both read and write transactions.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_same_id_xact_from_diff_masters_ictest_sequence.html">svt_axi_ordering_same_id_xact_from_diff_masters_ictest_sequence</a></td>
  <td class="compvalue">#- Drive a sequence of Write transactions with same AWID to the same Slave VIP<br> 
 from all masters simultaneously.<br> 
 #- Wait for all Write transactions to complete.<br>
 #- Drive a sequence of Read transactions with same ARID to the same Slave VIP<br>
 from all masters simultaneously.<br> 
 #- Program the Slave VIP to interleave read data.<br>
 #- Check that the Interconnect is forwarding the correct read data with respect to<br>
 address issued,to the appropriate Master.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_write_read_same_id_sequence_diff_masters_ictest_sequence.html">svt_axi_ordering_write_read_same_id_sequence_diff_masters_ictest_sequence</a></td>
  <td class="compvalue">#- Drive a sequence of Write transactions with a set of different AWID's to the<br>
 same Slave VIP(e.g sequence of IDs 1,2,3,4,5 from each Master) from all<br> 
 masters simultaneously.<br> 
 Note that the set of AWIDs used must remain same for all Masters.<br>
 #- Wait for all Write transactions to complete.<br>
 #- Drive a sequence of Read transactions with a set of different ARID's to the<br>
 same Slave VIP(e.g sequence of IDs 1,2,3,4,5 from each Master) from all<br> 
 masters simultaneously.<br>
 Note that the set of ARIDs used must remain same for all Masters.<br>
 #- Program the Slave VIP to interleave read data.<br>
 #- Check that the Interconnect is forwarding the correct read data with respect to<br> 
 address issued,to the appropriate Master.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi4_ordering_read_overlap_addr_same_id_device_memory_ictest_sequence.html">svt_axi4_ordering_read_overlap_addr_same_id_device_memory_ictest_sequence</a></td>
  <td class="compvalue">#- Program a randomly selected AXI4 Master VIP to drive two Read transactions to<br> 
 same Slave VIP with same ID and overlapping address (not same address).<br> 
 Select the address of first Read transaction randomly. Calculate the address<br> 
 for second Read transaction such that it is overlapping with address of first<br> 
 Read transaction. ARCACHE[1] should be set to 0, to indicate non-modifiable<br> 
 transactions(to device memory).<br>
 #- Within the sequence, wait for xact_request_received_event event issued by Slave VIP Port monitor.<br> 
 Check if the address of the transaction which triggered this event is same as<br> 
 address of the first read transaction. This validates that the read addresses<br> 
 arrived at the Slave VIP in the same order in which they were issuesd by the<br> 
 Master VIP.<br> 
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi4_ordering_read_overlap_addr_diff_id_device_memory_ictest_sequence.html">svt_axi4_ordering_read_overlap_addr_diff_id_device_memory_ictest_sequence</a></td>
  <td class="compvalue">#- Program a randomly selected AXI4 Master VIP to drive two Read transactions to<br> 
 same Slave VIP with different ID and overlapping address (not same address).<br> 
 Select the address of first Read transaction randomly. Calculate the address<br> 
 for second Read transaction such that it is overlapping with address of first<br> 
 Read transaction. ARCACHE[1] should be set to 0, to indicate non-modifiable<br> 
 transactions(to device memory).<br> 
 #- Within the sequence, wait for xact_request_received_event event issued by Slave VIP Port monitor.<br> 
 Check if the address of the transaction which triggered this event is same as<br> 
 address of the first read transaction. This validates that the read addresses<br> 
 arrived at the Slave VIP in the same order in which they were issuesd by the<br> 
 Master VIP.<br> 
    . </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi4_ordering_read_overlap_addr_diff_id_normal_memory_ictest_sequence.html">svt_axi4_ordering_read_overlap_addr_diff_id_normal_memory_ictest_sequence</a></td>
  <td class="compvalue">#- Program a randomly selected AXI4 Master VIP to drive two Read transactions to<br> 
 same Slave VIP with different ID and overlapping address (not same address).<br> 
 Select the address of first Read transaction randomly. Calculate the address<br> 
 for second Read transaction such that it is overlapping with address of first<br> 
 Read transaction. ARCACHE[1] should be set to 1, to indicate modifiable transactions<br>
 #- Within the sequence, wait for xact_request_received_event event issued by Slave VIP Port monitor.<br> 
 Check if the address of the transaction which triggered this event is same as<br> 
 address of the first read transaction. This validates that the read addresses<br> 
 arrived at the Slave VIP in the same order in which they were issued by the Master VIP.<br> 
    . </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi4_ordering_read_overlap_addr_same_id_normal_memory_ictest_sequence.html">svt_axi4_ordering_read_overlap_addr_same_id_normal_memory_ictest_sequence</a></td>
  <td class="compvalue">#- Program a randomly selected AXI4 Master VIP to drive two Read transactions to<br> 
 same Slave VIP with same ID and overlapping address (not same address).<br> 
 Select the address of first Read transaction randomly. Calculate the address<br> 
 for second Read transaction such that it is overlapping with address of first<br> 
 Read transaction. ARCACHE[1] should be set to 1, to indicate modifiable transactions<br>
 #- Within the sequence, wait for xact_request_received_event event issued by Slave VIP Port monitor.<br> 
 Check if the address of the transaction which triggered this event is same as<br> 
 address of the first read transaction. This validates that the read addresses<br> 
 arrived at the Slave VIP in the same order in which they were issued by the Master VIP.<br> 
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi4_ordering_write_overlap_addr_diff_id_normal_memory_ictest_sequence.html">svt_axi4_ordering_write_overlap_addr_diff_id_normal_memory_ictest_sequence</a></td>
  <td class="compvalue">#- Program the AXI Master VIP to drive multiple (4) write transactions for<br> 
 same Slave VIP with different ID, different (but overlapping) AWADDR to<br> 
 Normal memory.<br> 
 #- Make sure addresses in the transactions are overlapping. This will help to<br>
 validate that ordering is preserved for overlapping addresses for Normal Memory.<br>
 #- Check the write transactions are in same order at the Interconnect Master Port<br> 
 and Interconnect Slave Port.<br>
 #- Wait for the transaction to complete successfully.<br> 
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br> 
 Slaves_connected to the Interconnect DUT.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi4_ordering_write_overlap_addr_diff_id_device_memory_ictest_sequence.html">svt_axi4_ordering_write_overlap_addr_diff_id_device_memory_ictest_sequence</a></td>
  <td class="compvalue">#- Program the AXI Master VIP to drive multiple (4) write transactions for<br> 
 same Slave VIP with different ID, different (but overlapping) AWADDR to<br>
 Device memory.<br> 
 #- Make sure addresses in the transactions are overlapping.This will help to<br> 
 validate that ordering is preserved for overlapping addresses for Device<br>
 Memory.<br>
 #- Check the write transactions are in same order at the Interconnect Master Port<br>
 and Interconnect Slave Port.<br>
 #- Wait for the transaction to complete successfully.<br> 
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br> 
 Slaves connected to the Interconnect DUT<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_write_overlap_addr_same_id_device_memory_ictest_sequence.html">svt_axi_ordering_write_overlap_addr_same_id_device_memory_ictest_sequence</a></td>
  <td class="compvalue">#- Program the AXI Master VIP to drive multiple (4) write transactions for same<br> 
 Slave VIP with same ID, different (but overlapping) AWADDR to Device memory.<br> 
 #- Make sure addresses in the transactions are overlapping. This will help to <br> 
 validate that ordering is preserved for overlapping addresses for Device Memory.<br>
 #- Check the write transactions are in same order at the Interconnect Master Port<br> 
 and Interconnect Slave Port. Also check the IDs of all transactions at the<br> 
 Interconnect Master port are same.<br>
 #- Wait for the transaction to complete successfully.<br> 
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br> 
 Slaves connected to the Interconnect DUT.<br> 
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_write_read_same_id_device_memory_diff_slave_response_ictest_sequence.html">svt_axi_ordering_write_read_same_id_device_memory_diff_slave_response_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive two write transactions to two randomly selected<br> 
 slave, with non-repetitive data (incremental, random)<br>
 #- Program the Master VIP to drive two read transactions to same randomly selected<br> 
 Slave VIPs, with same ARID. Use the same address for read transactions as used<br> 
 by write transactions.<br>
 #- Check the RDATA are in same order at Interconnect Slave Port. This will be<br> 
 checked by data_integrity check in AXI System Monitor.<br>
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br> 
 Slaves connected to the Interconnect DUT<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_write_read_same_id_device_memory_same_slave_response_ictest_sequence.html">svt_axi_ordering_write_read_same_id_device_memory_same_slave_response_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive two write transactions to the same slave,<br> 
 with non-repetitive data (incremental, random)<br>
 #- Program the Master VIP to drive two read transactions for same Slave with<br>
 same ARID. Use the same address for read transactions as used by write<br>
 transactions.<br>
 #- Check the RDATA are in same order at Interconnect Slave Port. This will be<br>
 checked by data_integrity check in AXI System Monitor.<br>
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br> 
 Slaves connected to the Interconnect DUT<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi4_ordering_write_overlap_addr_same_id_normal_memory_ictest_sequence.html">svt_axi4_ordering_write_overlap_addr_same_id_normal_memory_ictest_sequence</a></td>
  <td class="compvalue">#- Program a randomly selected AXI4 Master VIP to drive two write transactions to<br> 
 same Slave VIP with same ID and overlapping address (not same address).<br> 
 Select the address of first write transaction randomly. Calculate the address<br> 
 for second write transaction such that it is overlapping with address of first<br> 
 write transaction. AWCACHE[1] should be set to 1, to indicate modifiable<br> 
 transactions.<br> 
 #- Wait for both the write transactions to end.<br>
 #- Program the AXI4 Master VIP to drive a read transaction to the same address as<br> 
 the second write transaction.<br>
 #- Compare the read data with data of second write transaction, which is the<br> 
 expected data.<br>
 #- Disable the data_integrity check as this check can falsely fire in case of<br> 
 outstanding transactions to same or overlapping address.<br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_write_read_same_id_device_memory_ictest_sequence.html">svt_axi_ordering_write_read_same_id_device_memory_ictest_sequence</a></td>
  <td class="compvalue">#- Program the AXI Master VIP to drive multiple write transactions for same Slave<br> 
 VIP with same ID to Device memory. Make sure address of the write transactions<br> 
 are non-overlapping.<br>
 #- Program the same Master VIP to drive multiple read transactions for same Slave<br> 
 VIP with same ID and ARADDR same as previous AWADDR to device memory.<br>
 #- Wait for the transaction to reach the Slave.<br>
 #- Check the read data is same as write data and in same order at the Interconnect<br> 
 Master Port and Interconnect Slave Port.<br>
 #- Wait for the transaction to complete successfully.<br> 
 #- Initiate the above stimulus from all Master VIPs sequentially towards the same<br> 
 Slaves connected to the Interconnect DUT.<br>
    . </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_write_same_id_device_memory_ictest_sequence.html">svt_axi_ordering_write_same_id_device_memory_ictest_sequence</a></td>
  <td class="compvalue">#- Program the AXI Master VIP to drive multiple (4) write transactions<br> 
 for same Slave VIP with same ID, different AWADDR to Device memory.<br> 
 #- Make sure addresses in the transactions are non-overlapping. This will<br> 
 help to validate that ordering is preserved even for non-overlapping addresses<br>
 for Device Memory.<br>
 #- Check the write transactions are in same order at the Interconnect Master Port<br> 
 and Interconnect Slave Port. Also check the IDs of all transactions at the<br> 
 Interconnect Master port are same.<br>
 #- Wait for the transaction to complete successfully.<br> 
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br>
 Slaves connected to the Interconnect DUT.<br>
    . </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_write_same_id_device_non_bufferable_memory_diff_slave_response_ictest_sequence.html">svt_axi_ordering_write_same_id_device_non_bufferable_memory_diff_slave_response_ictest_sequence</a></td>
  <td class="compvalue">#- Program a Master VIP to drive two normal write transactions to two different<br>
 randomly selected Slave VIPs and with same AWID.Program AWCACHE[1:0] to 2'b00,<br>
 to indicate non-modifiable, non-bufferable. This ensures that both write<br> 
 transactions reach the Slave VIP.<br>
 #- Program the Slave VIP to respond to first transaction with OKAY and second <br>
 transaction with SLVERR. Program the delays such that response to second write<br>
 transaction is sent first, that is, before response for first write transaction.<br>
 #- Check the BRESP are in same order at Interconnect Master Port. This will be <br>
 checked in the master sequence itself. Check that the response of the first <br>
 completed transaction is OKAY. Check that the response of second transaction <br>
 is SLVERR.<br>
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br>
 Slaves connected to the Interconnect DUT.<br> 
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_write_same_id_device_non_bufferable_memory_same_slave_response_ictest_sequence.html">svt_axi_ordering_write_same_id_device_non_bufferable_memory_same_slave_response_ictest_sequence</a></td>
  <td class="compvalue">#- Program a Master VIP to drive two normal write transactions to same Slave VIP <br>
 and with same AWID.Program AWCACHE[1:0] to 2'b00, to indicate non-modifiable,<br> 
 non-bufferable. This ensures that both Write transactions reach the Slave VIP.<br>
 #- Program the Slave VIP to respond to first transaction with OKAY and second<br> 
 transaction with SLVERR. Program random delays in the slave responses.<br>
 #- Check the BRESP are in same order at Interconnect Master Port. This will be <br>
 checked in the master sequence itself. Check that the response of the first <br>
 completed transaction is OKAY. Check that the response of second transaction <br>
 is SLVERR.<br>
 #- Initiate the above stimulus from all Master VIPs sequentially towards all <br>
 the Slaves connected to the Interconnect DUT.<br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_write_read_bufferable_memory_ictest_sequence.html">svt_axi_ordering_write_read_bufferable_memory_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive write transaction with AWCACHE[0]=1'b1.<br>
 Rest bits can be random.<br>
 #- After receiving write response, program the AXI Master VIP to drive read <br>
 transaction with same address as previous write with ARCACHE[3:0] as random.<br>
 #- Wait for the transaction to complete successfully. <br>
 #- Compare read data with write data.<br>
 #- Initiate the above stimulus from all Master VIPs sequentially towards all<br> 
 the Slaves connected to the Interconnect DUT.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ordering_write_device_non_bufferable_memory_ictest_sequence.html">svt_axi_ordering_write_device_non_bufferable_memory_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive write transaction with AWCACHE[1:0]=2'b00.<br>
 #- Check the transaction is not modified at the Interconnect Master Port.<br>
 #- Check Interconnect is not responding to the write transaction until Slave VIP<br>
 responds.<br>
 #- Wait for the transaction to complete successfully. <br>
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br>
 Slaves connected to the Interconnect DUT. <br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi3_cov_corner_cases_exclusive_cache_type_sequence.html">svt_axi3_cov_corner_cases_exclusive_cache_type_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive multiple transaction of Exclusive transaction <br>
 Program the Master VIP to wait for previous Exclusive<br>
 This sequece is for cover corner scenarios of exclusive transactions <br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_cov_corner_cases_addr_min_sequence.html">svt_axi_cov_corner_cases_addr_min_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive multiple transaction with min address range <br>
 selected atomic type of Normal read or write transaction <br>
 All other control fields are generated randomly. <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_cov_corner_cases_wstrb_sequence.html">svt_axi_cov_corner_cases_wstrb_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive multiple transaction with more probability <br>
 for wstrb corner scenarios. <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi3_random_read_write_locked_sequence.html">svt_axi3_random_read_write_locked_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive random locked transaction <br>
 Send Exclusive transaction with same xact_type and addr as of locked transaction<br> 
 to unlock the locked sequence and all other control fields generated randomly.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_normal_random_virtual_sequence.html">svt_axi_exclusive_normal_random_virtual_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive multiple transaction with randomly
 selected atomic type of Exclusive or Normal read transaction
 Program the Master VIP to wait for previous Exclusive or Normal
 transaction to end
 All other control fields are generated randomly.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_ordering_memory_suspend_response_sequence.html">svt_axi_slave_ordering_memory_suspend_response_sequence</a></td>
  <td class="compvalue">This sequence suspends the response of write transaction ,resumes it after 
 after read transactions reaches the slave. 
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_ordering_programmed_response_sequence.html">svt_axi_slave_ordering_programmed_response_sequence</a></td>
  <td class="compvalue">This sequence gets the slave response sequence item from slave sequencer.
 User can modify these responses. The sequence uses the built-in slave memory. 
 For write transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_locked_read_followed_by_excl_sequence.html">svt_axi_locked_read_followed_by_excl_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive Locked read transaction followed by <br>
 Exclusive read transaction with same control fields as previous<br> 
 lock read and all other control fields generated randomly.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_read_write_ictest_sequence.html">svt_axi_exclusive_read_write_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive Exclusive read transaction followed by <br>
 Exclusive write transaction with same control fields as previous<br> 
 Exclusive read and all other control fields generated randomly.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_burst_unaligned_addr_narrow_transfers_random_ictest_sequence.html">svt_axi_burst_unaligned_addr_narrow_transfers_random_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive random transactions with narrow transfers,<br>
 unaligned address and all other control fields generated randomly.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_burst_aligned_addr_narrow_transfers_random_ictest_sequence.html">svt_axi_burst_aligned_addr_narrow_transfers_random_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive random transactions with narrow transfers,<br>
 aligned address and all other control fields generated randomly.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_burst_unaligned_addr_full_data_width_random_ictest_sequence.html">svt_axi_burst_unaligned_addr_full_data_width_random_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive random transactions with burst size<br>
 (AxSIZE) equal to data width of AXI bus, unaligned address and all other<br>
 control fields generated randomly.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_burst_aligned_addr_full_data_width_random_ictest_sequence.html">svt_axi_burst_aligned_addr_full_data_width_random_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive random transactions with burst size<br>
 (AxSIZE) equal to data width of AXI bus, aligned address and all other control<br> 
 fields generated randomly.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_random_ictest_sequence.html">svt_axi_random_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive multiple random transaction.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_random_all_master_to_all_slave_sequence.html">svt_axi_random_all_master_to_all_slave_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive multiple random transaction to each Slave.<br>
 #- Initiate the above stimulus from all Master VIPs sequentially towards all<br>
 the Slaves connected to the IC DUT.<br>
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_decode_error_response_ictest_sequence.html">svt_axi_decode_error_response_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive Write/Read transaction. Configure the<br> 
 Master transaction such that it should fire a transaction having address<br> 
 which doesn't fall in any of the slaves. To determine an address which <br> 
 would issue DECERR, address map in system configuration will need to be<br> 
 referred.<br> 
 #- Check Interconnect responds with DECERR.<br>
 #- Initiate the above stimulus from all Master VIPs.<br> 
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_burst_write_with_strobe_deasserted_ictest_sequence.html">svt_axi_burst_write_with_strobe_deasserted_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive write transcation with all strobes = 1.<br> 
 This will initialize the memory to a known value.<br> 
 #- Program the Master VIP to drive write transcation to the same location<br> 
 of previous write transaction with all strobe bits = 0 for certain transfers. <br> 
 #- Program the Master VIP to drive Read transaction. <br> 
 #- Check the read data and compare it with write data (expected data).<br> 
 #- Initiate the above stimulus from all Master VIPs towards all the Slaves <br> 
 connected to the IC DUT.<br> 
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_burst_write_data_before_address_ictest_sequence.html">svt_axi_burst_write_data_before_address_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive Write transaction with Write data in <br> 
 Write Data Channel first, followed by Address on the Write Adderss <br> 
 Channel.<br> 
 #- Check Interconnect forwards the Write transaction to Slave VIP properly.<br> 
 #- Initiate the above stimulus from all Master VIPs sequentially towards all<br> 
 the Slaves connected to the IC DUT.<br> 
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_burst_write_read_with_zero_delay_ictest_sequence.html">svt_axi_burst_write_read_with_zero_delay_ictest_sequence</a></td>
  <td class="compvalue">#- Program the testbench to drive ARESETn from LOW to HIGH<br> 
 #- Program the Master VIP to drive Write/Read transaction in Write/Read <br> 
 Address/Data channel on the immediate active edge of ACLK after ARESETn <br> 
 becoming HIGH <br> 
 #- Wait for the transaction to complete successfully. <br> 
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_signal_timing_write_read_default_ready_ictest_sequence.html">svt_axi_signal_timing_write_read_default_ready_ictest_sequence</a></td>
  <td class="compvalue">#- Program the Master VIP to drive Write and read transactions.<br> 
 #- Configure the Master and Slave VIP default values of READY signal from
 the test.<br> 
 #- Check the Interconnect Master Port is driving VALID irrespective of READY <br> 
 from Slave. This will get tested through system configuration <br> 
 bus_inactivity_timeout.<br> 
 #- Initiate the above stimulus from all Master VIPs towards all the Slaves <br> 
 connected to the IC DUT.<br> 
    .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_transaction_sequence_library.html">svt_axi_ace_master_transaction_sequence_library</a></td>
  <td class="compvalue">AXI VIP provides a pre-defined AXI ACE Master sequence library
 svt_axi_ace_master_transaction_sequence_library, which can hold the AXI ACE Master
 sequences. The library by default has no registered sequences. You are
 expected to call
 <a class="ClassLink" href="./sequences/class_svt_axi_ace_master_transaction_sequence_library.html">svt_axi_ace_master_transaction_sequence_library</a> <b>::</b> <a class="ClassLink" href="./sequences/class_svt_axi_ace_master_transaction_sequence_library.html#item_populate_library">populate_library</a> method to
 populate the sequence library with master sequences provided with the VIP. The
 system configuration is provided to the <a class="ClassLink" href="./sequences/class_svt_axi_ace_master_transaction_sequence_library.html#item_populate_library">populate_library</a> method as an
 argument. Based on the system configuration, appropriate sequences are added to
 the sequence library. You can then load the sequence library in the system sequencer.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_readoncemakeinvalid_sequential_sequence.html">svt_axi_ace_master_readoncemakeinvalid_sequential_sequence</a></td>
  <td class="compvalue">#- Send a sequence of READONCEMAKEINVALID transactions to consecutive address locations
 #- The port from which the transactions are sent out are determined by port_id which can
 be passed via config_db. The port should be an ACE-Lite port.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_readoncemakeinvalid_sequence.html">svt_axi_ace_master_readoncemakeinvalid_sequence</a></td>
  <td class="compvalue">This sequence initiates ReadOnceMakeInvalid transaction from the ACE/ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. ReadOnceMakeInvalid transactions can be
 sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending ReadOnceMakeInvalid transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_readoncecleaninvalid_sequence.html">svt_axi_ace_master_readoncecleaninvalid_sequence</a></td>
  <td class="compvalue">This sequence initiates ReadOnceCleanInvalid transaction from the ACE/ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. ReadOnceCleanInvalid transactions can be
 sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending ReadOnceCleanInvalid transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_readoncecleaninvalid_sequential_sequence.html">svt_axi_ace_master_readoncecleaninvalid_sequential_sequence</a></td>
  <td class="compvalue">#- Send a sequence of READONCECLEANINVALID transactions to consecutive address locations
 #- The port from which the transactions are sent out are determined by port_id which can
 be passed via config_db. The port should be an ACE-Lite port.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_multipart_dvm_virtual_sequence.html">svt_axi_ace_master_multipart_dvm_virtual_sequence</a></td>
  <td class="compvalue">Sends Multi-Part DVM Transaction from randomly selected ports. While sending multipart dvm
 transactions it also sends dvm transactions from same port along with coherent shareable and
 non-shareable transactions from same and other ports. Multipart and singlepart DVM transactions
 are sent simulataneously from one or more randomly selected ports in parallel.
 Scenarios Covered::

<ul><li>
 independent write channel transaction progress along with dvm transactions

</li><li>
 independency of ID usage between write channel transactions and DVM transactions

</li><li>
 independent read channel transaction progress along with dvm transactions

</li><li>
 ID usage restrictions between read channel non-dvm transactions and DVM transactions

</li><li>
 multi-part DVM transactions

</li><li>
 multi-part DVM transactions with second part having DVM Sync and other opcodes

</li><li>
 multi-part DVM Sync transactions with second part having DVM Sync and other opcodes

</li><li>
 time overlapped multi-part dvm and non-multi-part dvm transactions

</li><li>
 time overlapped coherent write, coherent read and multi-part dvm and non-multi-part dvm transactions

</li></ul>
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_dvm_virtual_sequence.html">svt_axi_ace_master_dvm_virtual_sequence</a></td>
  <td class="compvalue">This sequence sends DVM operations followed by a DVM sync from one port or multiple
 ports of a given domain. Prior to sending DVM operations and DVM sync a few normal transactions
 as specified in num_pre_dvm_xacts is sent. The above sequence is repeated for sequence_length.
 The sequence also triggers another sequence that sends DVM Complete transactions from ports that receive DVM Syncs. 
 The sequence terminates only when DVM completes for each of the DVM syncs sent out
 from a port are received from the interconnect
 This sequence is not added to the library (except for documentation) because it kills any
 snoop response sequences supplied by the testbench to run a dvm specific snoop response. Adding
 it to the library and running it may cause undesirable results and therefore this sequence must 
 be run in a separate test</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_load_barrier_sequence.html">svt_axi_ace_master_load_barrier_sequence</a></td>
  <td class="compvalue">This sequence does the following:
 Send a number of transactions to load . The number of transactions sent
 is based on num_pre_barrier_loads. 
 Send a barrier pair
 Send a post barrier transaction that is associated to the barrier pair. This transaction
 will be send out only after the response to the barrier pair is received
 When the post barrier transaction ends, check that all pre barrier transactions have also
 ended. </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_nonshareable_store_barrier_load_sequence.html">svt_axi_ace_master_nonshareable_store_barrier_load_sequence</a></td>
  <td class="compvalue">This sequence does the following:
 Sends a number of pre barrier write transactions based on num_pre_barrier_stores
 Sends a barrier pair
 Sends post barrier read transaction to the same address.
 Since the reads are post barrier transactions, all the previous writes should be
 observable to the reads 
 All write transactions sends are WRITENOSNOOP transaction and read transactions
 are READNOSNOOP transactions</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_shareable_store_barrier_load_sequence.html">svt_axi_ace_master_shareable_store_barrier_load_sequence</a></td>
  <td class="compvalue">This sequence does the following:
 Sends a number of pre barrier store transactions based on num_pre_barrier_stores
 Sends a barrier pair
 Sends a post barrier flag transaction. Any master that can observe this flag should be
 able to observe the transactions before the barrier
 From another port in the same domain, the location written through the flag transaction is 
 continously read (load). When the value set through the flag transaction is read back, the loop 
 terminates. The flag transaction is a post-barrier transaction, so if its value is observable, 
 It then reads back all the locations written through the pre barrier store transactions and 
 checks that all the data that was written is read back correctly. Thus, this sequence is
 self-checking. Note that this step is not done if pre_barrier_xact_type is PRE_BARRIER_CACHE_MAINTENANCE 
 since the data is not available in cache maintenance transactions. Instead, the sequence checks 
 that when a post-barrier transaction completes all pre-barrier cache maintenance transactions
 should have completed.
 The ports on which the pre barrier stores and the loads are sent are randomly chosen
 based on configuration. The type of store transaction is based on the setting in 
 pre_barrier_xact_type. Loads can be READSHARED,READONCE,READCLEAN or
 READNOTSHAREDDIRTY. 
 Some interesting scenarios that can be exercised using this sequence are.
 Each of these scenarios is repeated for sequence_length:
 1. num_pre_barrier_stores=1,num_observers=1 : A single pre-barrier store
 followed by a post barrier flag with one observer reading the post barrier
 flag and later reading the location addressed by pre_barrier store. 
 2. num_pre_barrier_stores=1,num_observers>1 : A single pre-barrier store
 followed by a post barrier flag with many observers reading the post barrier
 flag and later reading the location addressed by pre_barrier store. 
 3. num_pre_barrier_stores>1,num_observers=1 : Many pre-barrier stores
 followed by a post barrier flag with one observer reading the post barrier
 flag and later reading the locations addressed by pre_barrier store. 
 4. num_pre_barrier_stores>1,num_observers>1 : Many pre-barrier stores
 followed by a post barrier flag with many observers reading the post barrier
 flag and later reading the locations addressed by pre_barrier store. 
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_two_master_concurrent_write_sequence.html">svt_axi_ace_master_two_master_concurrent_write_sequence</a></td>
  <td class="compvalue">This sequence sends cocurrent write transactions from two ports after initializing cache lines</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_read_during_coherent_write_sequence.html">svt_axi_ace_master_read_during_coherent_write_sequence</a></td>
  <td class="compvalue">This sequence sends coherent read transactions while sending coherent write
 transactions to the same address from another port. In most cases, the
 interconnect will have to refetch data from the memory, if none of the
 snoops returned data. This is because the first read may return data that
 is not being written through the coherent write transaction depending on
 whether the data reached the slave. Hence a second read will have to be
 issued to ensure that the latest data is available. The sequence creates a
 scenario where the interconnect is forced to refetch data from memory </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_overlapping_addr_sequence.html">svt_axi_ace_master_overlapping_addr_sequence</a></td>
  <td class="compvalue">This sequence attempts to create a scenario where random coherent
 transactions targetting the same address are initiated from two different
 masters in which one is an ACE master specified with first_port_id and 
 another one is an ACE/ACE_LITE master specified through second_port_id.
 If second_port_xact_type is <a class="ClassLink" href="./transaction/class_svt_axi_transaction.html">svt_axi_transaction</a> <b>::</b> <a class="ClassLink" href="./transaction/class_svt_axi_transaction.html#item_WRITENOSNOOP">WRITENOSNOOP</a> then the
 transactions will not be sent to same addresses as transactions from first_port_id, 
 but the transactions will be fired concurrently from the masters.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_snoop_during_memory_update_sequence.html">svt_axi_ace_master_snoop_during_memory_update_sequence</a></td>
  <td class="compvalue">This sequence attempts to create a scenario where an initiating master
 (given by first_port_id) receives a snoop to the same cacheline while
 transmitting a WRITEBACK, WRITECLEAN, WRITEEVICT or EVICT
 (referred to as memory update transactions). The relative
 weights of WRITEBACK,WRITECLEAN,WRITEEVICT or EVICT can be
 set by passing writeback_wt,writeclean_wt,writeevict_wt and evict_wt
 respectively, through the UVM/OVM configuration infrastructure.
 By default, WRITEBACK and WRITECLEAN transactions have a weight of 1
 while the other transactions have a weight of 0.
 The scenario first initializes cachelines to valid states
 before sending memory update transactions. Based on the kind of
 transaction sent, the following initial states are reached after
 cacheline initialization.
 WRITEBACK,WRITECLEAN: Unique Dirty.
 WRITEEVICT, EVICT: Unique Clean. 
  .
 The coherent transactions that can be sent from second_port_id are

<ul><li>
 CMO : MAKEINVALID, CLEANINVALID or CLEANSHARED
 STORE : MAKEUNIQUE, CLEANUNIQUE, READUNIQUE, WRITEUNIQUE or WRITELINEUNIQUE
 LOAD : READONCE, READSHARED, READCLEAN or READNOTSHAREDDIRTY.
 In case of CLEANUNIQUE the initial state must be shared state.(if cleanunique_wt is 1)
 After completing initialisation for memory update, readshared will be sent from 
 second_port_id to initialize the states to shared, for the cleanunique addresses.

</li></ul>

 If addr_mode_select is set from test, the sequence will fire memory update 
 transactions from first_port_id and coherent transactions from second_port_id
 to the same set of sequential addresses at the same time.
 If addr_mode_select is low, the sequence will fire memory update 
 transactions from first_port_id and coherent transactions from second_port_id
 to the same set of random addresses at the same time.
  .
 The combination of WRITEEVICT and CLEANUNIQUE cant be exercised because
 Initial state of WRITEEVICT must be Unique Clean,for CLEANUNIQUE any shared state
 so at the same time the states cant be in unique and shared. </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_random_exclusive_access_virtual_sequence.html">svt_axi_ace_random_exclusive_access_virtual_sequence</a></td>
  <td class="compvalue">Creates system wide random exclusive access sequence on ACE ports.
 Scenarios which are covered are as follows:</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_exclusive_access_virtual_sequence.html">svt_axi_ace_master_exclusive_access_virtual_sequence</a></td>
  <td class="compvalue">Basic Exclusive access sequeance
 This Sequence provides ACE Exclusive access at system level and can be used in any AXI_ACE master port to
 initiate Exclusive access transaction sequence using this.
<br>
 Transaction Sequences Used: Exclusive Load followed by Exclusive store 

<ul><li>
 Initialize cache lines if initialize_cachelines bit is set 

</li><li>
 Issue READCLEAN or READSHARED to load location and wait for the transaction to end

</li><li>
 Check the cache line state

<ul><li>
 if in Shared state issue CLEANUNIQUE 

</li><li>
 if in Invalid state then restart Exclusive Access

</li><li>
 else do nothing as Master can store directly to the cacheline no need to inform Interconnect

</li></ul>


</li><li>
 Stored data is updated to memory through WRITEBACK transaction

</li></ul>

<br>
 Please note, for generation of exclusive access transactions, svt_axi_port_configuration :: exclusive_access_enable 
 should be set for the targeted master and svt_axi_port_configuration :: speculative_read_enable should be set to zero
 for that master as well<br>
 <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_evict_sequential_sequence.html">svt_axi_ace_master_evict_sequential_sequence</a></td>
  <td class="compvalue">#- Send a sequence of EVICT transactions to consecutive address locations
 #- The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. 
 #- A sequence of MAKEUNIQUE and WRITECLEAN transactions are sent prior to
 sending the EVICT transactions so that the cachelines are in Unique
 Clean State.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_writeevict_sequential_sequence.html">svt_axi_ace_master_writeevict_sequential_sequence</a></td>
  <td class="compvalue">#- Send a sequence of WRITEEVICT transactions to consecutive address locations
 #- The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. The port must be an ACE port and must have 
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_writeevict_enable">writeevict_enable</a> set.
 #- A sequence of MAKEUNIQUE and WRITECLEAN transactions are sent prior to
 sending the WRITEEVICT transactions so that the cachelines are in Unique
 Clean State.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_makeunique_sequential_sequence.html">svt_axi_ace_master_makeunique_sequential_sequence</a></td>
  <td class="compvalue">#- Send a sequence of MAKEUNIQUE transactions to consecutive address locations
 #- The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. The port should be an ACE port.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_cmo_shareable_txn_sequence.html">svt_axi_ace_master_cmo_shareable_txn_sequence</a></td>
  <td class="compvalue">#- Send a sequence of shareable allocating Readclean transactions followed by 
 #- cache maintenance transactions to same address locations
 #- cache maintenance transactions can be MAKEINVALID, CLEANSHARED or CLEANINVALID
 #- transactions. 
 #- The weights for these transactions can be passed through uvm_config_db.
 #- The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. The port can be ACE or ACE-Lite port.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_cachemaintenance_sequential_sequence.html">svt_axi_ace_master_cachemaintenance_sequential_sequence</a></td>
  <td class="compvalue">#- Send a sequence of cache maintenance transactions to consecutive address locations
 #- Cache maintenance transactions can be MAKEINVALID, CLEANSHARED or CLEANINVALID
 transactions.
 #- The weights for these transactions can be passed through uvm_config_db.
 #- The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. The port can be ACE or ACE-Lite port.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_writeunique_writelineunique_sequential_sequence.html">svt_axi_ace_master_writeunique_writelineunique_sequential_sequence</a></td>
  <td class="compvalue">#- Send a sequence of WRITEUNIQUE/WRITELINEUNIQUE transactions to consecutive address locations
 #- The weights for these transactions can be passed through uvm_config_db.
 #- The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. The port can be ACE or ACE-Lite port.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_cleanunique_sequential_sequence.html">svt_axi_ace_master_cleanunique_sequential_sequence</a></td>
  <td class="compvalue">#- Send a sequence of CLEANUNIQUE transactions to consecutive address locations
 #- The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. 
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_writeback_writeclean_sequential_sequence.html">svt_axi_ace_master_writeback_writeclean_sequential_sequence</a></td>
  <td class="compvalue">#- Send a sequence of WRITEBACK/WRITECLEAN transactions to consecutive address locations
 #- The weights for these transactions can be passed through uvm_config_db.
 The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. 
 #- A sequence of MAKEUNIQUE transactions are sent prior to sending the WRITEBACK transactions
 so that the cachelines are in Unique Dirty State.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_read_type_shareable_region_sequential_sequence.html">svt_axi_ace_master_read_type_shareable_region_sequential_sequence</a></td>
  <td class="compvalue">#- Send a sequence of shareable read transactions to consecutive address locations
 #- Shareable read transactions can be READONCE, READCLEAN, READNOTSHAREDDIRTY, READSHARED
 or READUNIQUE. The weights for these transactions can be passed through uvm_config_db.
 The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. If the port is an ACE-Lite port, only READONCE transactions
 are sent. All transactions sent are cacheline size transactions.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_writenosnoop_readnosnoop_sequential_sequence.html">svt_axi_ace_master_writenosnoop_readnosnoop_sequential_sequence</a></td>
  <td class="compvalue">#- Send a sequence of writenosnoop transactions to consecutive address locations
 #- Wait for all writenosnoop transactions to complete. <br>
 #- Send a sequence of readnosnoop transactions to the same set of addresses
 targetted by the writenosnoop transactions. <br>
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br></td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_writeevict_sequence.html">svt_axi_ace_master_writeevict_sequence</a></td>
  <td class="compvalue">This sequence initiates WriteEvict transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. WriteEvict transactions can be sent only
 when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending WriteEvict transactions, cachelines of masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_evict_sequence.html">svt_axi_ace_master_evict_sequence</a></td>
  <td class="compvalue">This sequence initiates Evict transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. Evict transactions can be sent only
 when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending Evict transactions, cachelines of masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_writeclean_sequence.html">svt_axi_ace_master_writeclean_sequence</a></td>
  <td class="compvalue">This sequence initiates WriteClean transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. WriteClean transactions can be sent only
 when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending WriteClean transactions, cachelines of masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_writeback_sequence.html">svt_axi_ace_master_writeback_sequence</a></td>
  <td class="compvalue">This sequence initiates WriteBack transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. WriteBack transactions can be sent only
 when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending WriteBack transactions, cachelines of masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_writeuniquefullstash_sequence.html">svt_axi_ace_master_writeuniquefullstash_sequence</a></td>
  <td class="compvalue">This sequence initiates writeuniquefullstash transaction from the ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. writeuniquefullstash transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a> and
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ace_version">ace_version</a> is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_VERSION_2_0">ACE_VERSION_2_0</a> and <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_cache_stashing_enable">cache_stashing_enable</a>
 is set to 1.
 Before sending writeuniquefullstash transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_stashtranslation_sequence.html">svt_axi_ace_master_stashtranslation_sequence</a></td>
  <td class="compvalue">This sequence initiates stashtranslation transaction from the ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. stashtranslation transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a> and <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ace_version">ace_version</a> is set
 to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_VERSION_2_0">ACE_VERSION_2_0</a> and <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_cache_stashing_enable">cache_stashing_enable</a>
 is set to 1.
 Before sending stashtranslation transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_stashonceshared_sequence.html">svt_axi_ace_master_stashonceshared_sequence</a></td>
  <td class="compvalue">This sequence initiates stashonceshared transaction from the ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. stashonceshared transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a> and <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ace_version">ace_version</a> is set
 to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_VERSION_2_0">ACE_VERSION_2_0</a> and <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_cache_stashing_enable">cache_stashing_enable</a>
 is set to 1.
 Before sending stashonceshared transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_stashonceunique_sequence.html">svt_axi_ace_master_stashonceunique_sequence</a></td>
  <td class="compvalue">This sequence initiates stashonceunique transaction from the ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. stashonceunique transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a> and <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ace_version">ace_version</a> is set
 to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_VERSION_2_0">ACE_VERSION_2_0</a> and <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_cache_stashing_enable">cache_stashing_enable</a>
 is set to 1.
 Before sending stashonceunique transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_writeuniqueptlstash_sequence.html">svt_axi_ace_master_writeuniqueptlstash_sequence</a></td>
  <td class="compvalue">This sequence initiates WriteUniqueptlstash transaction from the ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. writeuniqueptlstash transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a> and <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ace_version">ace_version</a> is set
 to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_VERSION_2_0">ACE_VERSION_2_0</a> and <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_cache_stashing_enable">cache_stashing_enable</a>
 is set to 1.
 Before sending writeuniqueptlstash transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_writelineunique_sequence.html">svt_axi_ace_master_writelineunique_sequence</a></td>
  <td class="compvalue">This sequence initiates WriteLineUnique transaction from the ACE/ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. WriteLineUnique transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending WriteLineUnique transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_writeunique_sequence.html">svt_axi_ace_master_writeunique_sequence</a></td>
  <td class="compvalue">This sequence initiates WriteUnique transaction from the ACE/ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. WriteUnique transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending WriteUnique transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_writenosnoop_sequence.html">svt_axi_ace_master_writenosnoop_sequence</a></td>
  <td class="compvalue">This sequence initiates WriteNoSnoop transaction from the ACE/ACE_Lite
 master specified with port_id , which can be a random port or a specific
 port configured by the user through uvm_config_db. </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_makeinvalid_sequence.html">svt_axi_ace_master_makeinvalid_sequence</a></td>
  <td class="compvalue">This sequence initiates MakeInvalid transaction from the ACE/ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. MakeInvalid transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending MakeInvalid transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_cleaninvalid_sequence.html">svt_axi_ace_master_cleaninvalid_sequence</a></td>
  <td class="compvalue">This sequence initiates CleanInvalid transaction from the ACE/ACE-Lite
 master specified with port_id , which can be a random port or a specific
 port configured by the user through uvm_config_db. CleanInvalid
 transactions can be sent only when the
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master corresponding
 to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>. Before sending CleanInvalid
 transactions, cachelines of peer masters are initialized to random, valid
 states. Initialisation is done through front door access, by sending
 specific transactions from the initiating master (corresponding to port_id)
 and peer masters. Please look up the documentation of
 <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html">svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence</a></td>
  <td class="compvalue">This sequence initiates concurrent random non-dvm transactions from first_port_id and
 dvm transactions from dvm_port_id. These ports can be a random port or a specifc port 
 configured by user through uvm_config_db. Based on the interface type of first_port_id, 
 a transction type as set in first_port_xact_type is sent from first_port_id. 
 Before sending the transactions, cachelines of peer masters are initialized to random valid states. 
 Initialisation is done through front door access, by sending specific transactions from the 
 initiating master (corresponding to first_port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_cleansharedpersist_sequence.html">svt_axi_ace_master_cleansharedpersist_sequence</a></td>
  <td class="compvalue">This sequence initiates CleanSharedPersist transaction from the ACE/ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. CleanSharedPersist transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending CleanSharedPersist transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_cleanshared_sequence.html">svt_axi_ace_master_cleanshared_sequence</a></td>
  <td class="compvalue">This sequence initiates CleanShared transaction from the ACE/ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. CleanShared transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending CleanShared transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_writefull_with_cmo_on_write_sequence.html">svt_axi_ace_master_writefull_with_cmo_on_write_sequence</a></td>
  <td class="compvalue">This sequence initiates WRITEFULLCMO where cmo_on_write_xact_type transaction
 can be a random transaction configured by user through uvm_config_db, from the ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. WriteplusCMO transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending cleanshared_on_write transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_writeptl_with_cmo_on_write_sequence.html">svt_axi_ace_master_writeptl_with_cmo_on_write_sequence</a></td>
  <td class="compvalue">This sequence initiates WRITEPTLCMO where cmo_on_write_xact_type transaction
 can be a random transaction configured by user through uvm_config_db, from the ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. WriteplusCMO transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending cleanshared_on_write transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_cleanshareddeeppersist_on_write_sequence.html">svt_axi_ace_master_cleanshareddeeppersist_on_write_sequence</a></td>
  <td class="compvalue">This sequence initiates cleanshareddeeppersist_on_write transaction from the ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. cleanshareddeeppersist_on_write transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending cleanshareddeeppersist_on_write transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_cleansharedpersist_on_write_sequence.html">svt_axi_ace_master_cleansharedpersist_on_write_sequence</a></td>
  <td class="compvalue">This sequence initiates cleansharedpersist_on_write transaction from the ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. cleansharedpersist_on_write transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending cleansharedpersist_on_write transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_cleaninvalid_on_write_sequence.html">svt_axi_ace_master_cleaninvalid_on_write_sequence</a></td>
  <td class="compvalue">This sequence initiates cleaninvalid_on_write transaction from the ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. cleaninvalid_on_write transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending cleaninvalid_on_write transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_cleaninvalidpopa_on_write_sequence.html">svt_axi_ace_master_cleaninvalidpopa_on_write_sequence</a></td>
  <td class="compvalue">This sequence initiates cleaninvalidpopa_on_write transaction from the ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. cleaninvalidpopa_on_write transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending cleaninvalidpopa_on_write transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_cleanshared_on_write_sequence.html">svt_axi_ace_master_cleanshared_on_write_sequence</a></td>
  <td class="compvalue">This sequence initiates CleanShared_on_write transaction from the ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. cleanshared_on_write transactions can
 be sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending cleanshared_on_write transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_cleanunique_sequence.html">svt_axi_ace_master_cleanunique_sequence</a></td>
  <td class="compvalue">This sequence initiates CleanUnique transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. CleanUnique transactions can be sent only
 when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending CleanUnique transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_readunique_sequence.html">svt_axi_ace_master_readunique_sequence</a></td>
  <td class="compvalue">This sequence initiates ReadUnique transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. ReadUnique transactions can be sent only
 when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending ReadUnique transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_readnotshareddirty_sequence.html">svt_axi_ace_master_readnotshareddirty_sequence</a></td>
  <td class="compvalue">This sequence initiates ReadNotSharedDirty transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. ReadNotSharedDirty transactions can be sent only
 when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending ReadNotSharedDirty transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_readonce_sequence.html">svt_axi_ace_master_readonce_sequence</a></td>
  <td class="compvalue">This sequence initiates ReadOnce transaction from the ACE/ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. ReadOnce transactions can be
 sent only when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending ReadOnce transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_readnosnoop_sequence.html">svt_axi_ace_master_readnosnoop_sequence</a></td>
  <td class="compvalue">This sequence initiates ReadNoSnoop transaction from the ACE/ACE_LITE
 master specified with port_id , which can be a random port or a specific
 port configured by the user through uvm_config_db. </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_readclean_sequence.html">svt_axi_ace_master_readclean_sequence</a></td>
  <td class="compvalue">This sequence initiates ReadClean transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. ReadClean transactions can be sent only
 when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending ReadClean transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_readshared_sequence.html">svt_axi_ace_master_readshared_sequence</a></td>
  <td class="compvalue">This sequence initiates Readshared transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. ReadShared transactions can be sent only
 when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending Readshared transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_makeunique_sequence.html">svt_axi_ace_master_makeunique_sequence</a></td>
  <td class="compvalue">This sequence initiates MakeUnique transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. MakeUnique transactions can be sent only
 when the <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending Makeunique transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_barrier_base_virtual_sequence.html">svt_axi_ace_master_barrier_base_virtual_sequence</a></td>
  <td class="compvalue">This sequence is a base class for all barier based sequences. This sequence cannot be run
 as such, but contains methods which are used by other barrier sequences
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_two_port_overlapping_addr_cmo_and_store_sequential_sequence.html">svt_axi_ace_master_two_port_overlapping_addr_cmo_and_store_sequential_sequence</a></td>
  <td class="compvalue">Sends a set of concurrent, sequential cmo accesses from first_port_id and store
 accesses from second_port_id to the same set of overlapping addresses. 
 CMO type transactions can be MAKEINVALID, CLEANINVALID
 or CLEANSHARED.The store type transactions can be MAKEUNIQUE, READUNIQUE, CLEANUNIQUE,
 WRITEUNIQUE or WRITELINEUNIQUE based on the interface types of the ports and the weights.
 an initialisation procedure is invoked based on the following sequence, unless
 Prior to sending the cmo and store transaction bypass_cache_initialisation is set:

<ul><li>
 In order that the store transactions can be fired from various initial states. 

</li></ul>


<ul><li>
 If second_port_cleanunique_wt is not zero, cachelines are
 initialised, since CLEANUNIQUE can be sent only from a cacheline in shared
 state. Only cachelines from which CLEANUNIQUE needs to be sent are
 initialized. The number of CLEANUNIQUE transactions sent are determined by
 the formula sequence_length*first_port_cleanunique_wt/(sum of weights of
 all xact types in second port). Initialisation is done by sending
 MAKEUNIQUE transactions from one ACE port and READSHARED transactions from
 another ACE port to the same set of addresses. Snoop transactions for
 READSHARED type snoop are programmed (in the corresponding tests) to always
 assert <a class="ClassLink" href="./transaction/class_svt_axi_snoop_transaction.html">svt_axi_snoop_transaction</a> <b>::</b> <a class="ClassLink" href="./transaction/class_svt_axi_snoop_transaction.html#item_snoop_resp_datatransfer">snoop_resp_datatransfer</a> and
 <a class="ClassLink" href="./transaction/class_svt_axi_snoop_transaction.html">svt_axi_snoop_transaction</a> <b>::</b> <a class="ClassLink" href="./transaction/class_svt_axi_snoop_transaction.html#item_snoop_resp_isshared">snoop_resp_isshared</a> so that a shared state of
 the cacheline can be acheived in both masters. All shared cachelines in
 first_port_id are invalidated so that the cmo transactions can be sent on
 the interface. 

</li></ul>

 After this initialisation, sequential cmo access from first_port_id and
 sequential store from second_port_id are sent.
 .
 Sometimes if the cmo transactions snoops the second_port firstly and
 second port transaction is CLEANUNIQUE transaction means, there is a chance of
 invalidation of the cache line of second_port. By the result of this scenario
 the second_port may drop the CLEANUNIQUE transactions, Because CLEANUNIQUE
 cant be sent from INVALID state.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_two_port_overlapping_addr_store_and_load_sequential_sequence.html">svt_axi_ace_master_two_port_overlapping_addr_store_and_load_sequential_sequence</a></td>
  <td class="compvalue">Sends a set of concurrent, sequential store accesses from first_port_id and load
 accesses from second_port_id to the same set of overlapping addresses. The
 store type transactions can be MAKEUNIQUE, READUNIQUE, CLEANUNIQUE,
 WRITEUNIQUE or WRITELINEUNIQUE based on the interface types of the ports
 and the weights. Load type transactions can be READONCE, READCLEAN,
 READSHARED or READNOTSHAREDDIRTY. Prior to sending the store and load transaction
 an initialisation procedure is invoked based on the following sequence, unless
 bypass_cache_initialisation is set:

<ul><li>
 In order that the load transactions return some valid data,
 WRITELINEUNIQUE transactions are sent to update memory. 

</li></ul>


<ul><li>
 If first_port_cleanunique_wt is not zero, cachelines are
 initialised, since CLEANUNIQUE can be sent only from a cacheline in shared
 state. Only cachelines from which CLEANUNIQUE needs to be sent are
 initialized. The number of CLEANUNIQUE transactions sent are determined by
 the formula sequence_length*first_port_cleanunique_wt/(sum of weights of
 all xact types in first port). Initialisation is done by sending
 MAKEUNIQUE transactions from one ACE port and READSHARED transactions from
 another ACE port to the same set of addresses. Snoop transactions for
 READSHARED type snoop are programmed (in the corresponding tests) to always
 assert <a class="ClassLink" href="./transaction/class_svt_axi_snoop_transaction.html">svt_axi_snoop_transaction</a> <b>::</b> <a class="ClassLink" href="./transaction/class_svt_axi_snoop_transaction.html#item_snoop_resp_datatransfer">snoop_resp_datatransfer</a> and
 <a class="ClassLink" href="./transaction/class_svt_axi_snoop_transaction.html">svt_axi_snoop_transaction</a> <b>::</b> <a class="ClassLink" href="./transaction/class_svt_axi_snoop_transaction.html#item_snoop_resp_isshared">snoop_resp_isshared</a> so that a shared state of
 the cacheline can be acheived in both masters. All shared cachelines in
 second_port_id are invalidated so that the load transactions can be sent on
 the interface. 

</li></ul>

 After this initialisation, sequential stores from first_port_id and
 sequential loads from second_port_id are sent.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_two_port_overlapping_addr_load_cmo_sequential_sequence.html">svt_axi_ace_master_two_port_overlapping_addr_load_cmo_sequential_sequence</a></td>
  <td class="compvalue">Sends a set of concurrent, sequential load or cmo accesses from first_port_id and
 load or cmo accesses from second_port_id based on the interface types of the 
 ports and the weights selected from corresponding tests to the same set 
 of overlapping addresses. Load type transactions can be READONCE, READCLEAN, READSHARED
 or READNOTSHAREDDIRTY. cmo type transactions can be MAKEINVALID, CLEANINVALID
 and CLEANSHARED. Prior to sending the load transaction an
 initialisation procedure is invoked based on the following sequence, unless
 bypass_cache_initialisation is set:

<ul><li>
 In order that the load transactions return some valid data,
 incase of ACE port MAKEUNIQUE followed by WRITEBACK are sent to update memory. 
 incase of ACE_LITE port WRITELINEUNIQUE transactions are sent to update memory. 

</li></ul>

 After this initialisation, sequential load or sequential cmo from first_port_id and
 sequential load or sequential cmo from second_port_id are sent concurrently to the same 
 set of addresses.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_two_port_overlapping_addr_store_sequential_sequence.html">svt_axi_ace_master_two_port_overlapping_addr_store_sequential_sequence</a></td>
  <td class="compvalue">Sends a set of concurrent, sequential store accesses from two ports to the
 same set of overlapping addresses. The store type transactions can be
 MAKEUNIQUE, READUNIQUE, CLEANUNIQUE, WRITEUNIQUE or WRITELINEUNIQUE based
 on the interface types of the ports and the weights. If
 first_port_cleanunique_wt or second_port_cleanunique_wt is not zero,
 cachelines are initialised since CLEANUNIQUE can be sent only from a
 cacheline in shared state. Only cachelines from which CLEANUNIQUE needs to
 be sent are initialized. The number of CLEANUNIQUE transactions sent are
 determined by the formula sequence_length*cleanunique_wt/(sum of weights of
 all xact types). Initialisation is done by sending MAKEUNIQUE transactions
 from one ACE port and READSHARED transactions from another ACE port to the
 same set of addresses. Snoop transactions for READSHARED type snoop are
 programmed (in the corresponding tests) to always assert
 <a class="ClassLink" href="./transaction/class_svt_axi_snoop_transaction.html">svt_axi_snoop_transaction</a> <b>::</b> <a class="ClassLink" href="./transaction/class_svt_axi_snoop_transaction.html#item_snoop_resp_datatransfer">snoop_resp_datatransfer</a> and
 <a class="ClassLink" href="./transaction/class_svt_axi_snoop_transaction.html">svt_axi_snoop_transaction</a> <b>::</b> <a class="ClassLink" href="./transaction/class_svt_axi_snoop_transaction.html#item_snoop_resp_isshared">snoop_resp_isshared</a> so that a shared state of
 the cacheline can be acheived in both masters. Once cachelines are
 initialised, sequential stores from first_port_id and second_port_id are
 made.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_two_port_base_sequential_virtual_sequence.html">svt_axi_ace_master_two_port_base_sequential_virtual_sequence</a></td>
  <td class="compvalue">Base class from which all virtual sequences for sequential accesses to overlapping addresses are extended</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_two_port_base_virtual_sequence.html">svt_axi_ace_master_two_port_base_virtual_sequence</a></td>
  <td class="compvalue">Base class from which all ACE intermediate level sequences will be extended. </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_single_port_base_virtual_sequence.html">svt_axi_ace_master_single_port_base_virtual_sequence</a></td>
  <td class="compvalue">Base class from which all ACE basic level sequences will be extended. </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_exclusive_access_sequence.html">svt_axi_ace_exclusive_access_sequence</a></td>
  <td class="compvalue">This sequence is used to create Exclusive Access Transactions at Master port level<br>
<br>
 Transaction Sequences Used: Exclusive Load followed by Exclusive store 

<ul><li>
 Initialize cache lines if initialize_cachelines bit is set 

</li><li>
 Issue READCLEAN or READSHARED to load location and wait for the transaction to end

</li><li>
 Check the cache line state

<ul><li>
 if in Shared state issue CLEANUNIQUE 

</li><li>
 if in Invalid state then restart Exclusive Access

</li><li>
 else do nothing as Master can store directly to the cacheline no need to inform Interconnect

</li></ul>


</li><li>
 Stored data is updated to memory through WRITEBACK transaction

</li></ul>

 <br>
 Please note, for generation of exclusive access transactions, svt_axi_port_configuration :: exclusive_access_enable 
 should be set for the targeted master. <br>
 <br> </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_barrier_readnosnoop_sequence.html">svt_axi_ace_barrier_readnosnoop_sequence</a></td>
  <td class="compvalue">Sends a single READNOSNOOP transaction that reads from the same location 
 as write_xact. Associates the READ to a barrier based on associate_barrier</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_barrier_pair_sequence.html">svt_axi_ace_barrier_pair_sequence</a></td>
  <td class="compvalue">Sends a barrier pair</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_barrier_flag_read_xact_sequence.html">svt_axi_ace_barrier_flag_read_xact_sequence</a></td>
  <td class="compvalue">Sends a single READONCE transaction that writes into a location within the
 given domain type and address. The transaction addresses a single byte and is meant as one 
 which reads a flag set by another transaction. Typically this is used to read a flag 
 set through a post barrier transaction sent from another port.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_barrier_flag_write_xact_sequence.html">svt_axi_ace_barrier_flag_write_xact_sequence</a></td>
  <td class="compvalue">Sends a single WRITEUNIQUE transaction that writes into a location within the
 given domain type. The transaction addresses a single byte and is meant as a flag
 which can later be read by other transactions. Typically this is used as a post barrier
 transaction to signal availability/observability of a number of pre barrier transactions</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_dvm_complete_sequence.html">svt_axi_ace_master_dvm_complete_sequence</a></td>
  <td class="compvalue">This sequence sends DVM Complete transactions from ACE or ACE-Lite+DVM Master
 ports. It takes care of the ACE protocol requirement that DVM Sync handshake
 on the snoop address channel be observed before issuing DVM Complete transaction. </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_dvm_base_sequence.html">svt_axi_ace_master_dvm_base_sequence</a></td>
  <td class="compvalue">This sequence generates dvm transactions with all possible dvm message types
 from ACE or ACE-Lite+DVM master ports. This sequence is used as a base
 sequence for higher level sequences, with proper constraints for sequence
 members dvm_message_type and seq_xact_type </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_generic_sequence.html">svt_axi_ace_master_generic_sequence</a></td>
  <td class="compvalue">Generic sequence that can be used to generate transactions of all types on
 a master sequencer. All controls are provided in the base class
 svt_axi_ace_master_base_sequence. Please refer documentation of
 svt_axi_ace_master_base_sequence for controls provided. This class only
 adds constraints to make sure that it can be directly used in a testcase
 outside of a virtual sequence.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_cacheline_invalidation.html">svt_axi_cacheline_invalidation</a></td>
  <td class="compvalue">This sequence invalidates the cache line of a master.
 It checks the state of the cache line and initiaties the appropriate transaction
 If the cacheline state is dirty, a WRITEBACK is initiated.
 If the cacheline state is clean, an EVICT is initiated.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a></td>
  <td class="compvalue">This sequence initializes the cache line of all masters.
 This is done by:
 Initiating MakeUnique from 'initiating masters sequencer'
 Initiating Writeclean for some cachelines of masters.
 Initiating ReadShared from rest of ports that are ACE. 
 If use_parent_sequence_params is set, this sequence initializes all
 the addresses of transactions in the parent sequence. If not set,
 it initializes the address given in init_addr</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_basic_writeclean_full_cacheline.html">svt_axi_basic_writeclean_full_cacheline</a></td>
  <td class="compvalue">This sequence generates a writeclean transaction for a full cacheline.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_basic_writeback_full_cacheline.html">svt_axi_basic_writeback_full_cacheline</a></td>
  <td class="compvalue">This sequence generates a writeback transaction for a full cacheline.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_base_virtual_sequence.html">svt_axi_ace_master_base_virtual_sequence</a></td>
  <td class="compvalue">This is a virtual sequence and is the base class for other virtual sequences
 in the sequence library. The sequence spawns off a thread that waits on an
 event before it starts a sequence to initialize cachelines of peer masters. </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_base_sequence.html">svt_axi_ace_master_base_sequence</a></td>
  <td class="compvalue">Base class from which all the ACE non-virtual sequences are extended. This
 class is the base class for sequences that run on multiple master
 sequencers. In addition to being extended to create new sequences, this
 sequence is also called within some virtual sequences like
 svt_axi_cacheline_initialization and svt_axi_cacheline_invalidation. This
 sequence cannot be used as is, but must be called from within a virtual
 sequence that is extended from svt_axi_ace_master_base_virtual_sequence.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_atomic_swap_xact_base_virtual_sequence.html">svt_axi_master_atomic_swap_xact_base_virtual_sequence</a></td>
  <td class="compvalue">This sequence serves as a base sequence to create atomic swap type transactions</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_atomic_compare_xact_base_virtual_sequence.html">svt_axi_master_atomic_compare_xact_base_virtual_sequence</a></td>
  <td class="compvalue">This sequence serves as a base sequence to create atomic compare type transactions</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_atomic_load_xact_base_virtual_sequence.html">svt_axi_master_atomic_load_xact_base_virtual_sequence</a></td>
  <td class="compvalue">This sequence serves as a base sequence to create atomic load type transactions</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_atomic_store_xact_base_virtual_sequence.html">svt_axi_master_atomic_store_xact_base_virtual_sequence</a></td>
  <td class="compvalue">This sequence serves as a base sequence to create atomic store type transactions</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_system_random_sequence.html">svt_axi_system_random_sequence</a></td>
  <td class="compvalue">This sequence allows unconstrained random traffic for all ports</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_system_base_sequence.html">svt_axi_system_base_sequence</a></td>
  <td class="compvalue">This sequence creates a reporter reference</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_service_qos_read_accept_update_sequence.html">svt_axi_slave_service_qos_read_accept_update_sequence</a></td>
  <td class="compvalue">
 svt_axi_slave_service_qos_read_accept_update_sequence
 This sequence creates a qos read accept level update request.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_service_qos_write_accept_update_sequence.html">svt_axi_slave_service_qos_write_accept_update_sequence</a></td>
  <td class="compvalue">
 svt_axi_slave_service_qos_write_accept_update_sequence
 This sequence creates a qos write accept level update request.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_service_random_sequence.html">svt_axi_slave_service_random_sequence</a></td>
  <td class="compvalue">
 svt_axi_slave_service_random_sequence
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_service_base_sequence.html">svt_axi_slave_service_base_sequence</a></td>
  <td class="compvalue">
 svt_axi_slave_service_base_sequence: This is the base class for
 svt_axi_service based sequences. All other svt_axi_service
 sequences are extended from this sequence.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_reorder_chunk_response_sequence.html">svt_axi_slave_reorder_chunk_response_sequence</a></td>
  <td class="compvalue">This sequence generates reordered chunk responses. This sequence gets transactions from master and 
 sends the out of order chunk responses with valid rchunkstrb and rchunknum values.
 This sequence runs forever, and so is not registered with the slave sequence
 library.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_rchunkv_0_sequence.html">svt_axi_slave_rchunkv_0_sequence</a></td>
  <td class="compvalue">Abstract:
 Class svt_axi_slave_reorder_chunk_response_sequence defines a sequence class that
 the testbench uses to provide slave response to the Slave agent present in
 the System agent. The sequence receives a response object of type
 svt_axi_slave_transaction from slave sequencer. The sequence class then
 randomizes the response with constraints and provides it to the slave driver
 which reorder based on the priority within the slave agent,when the active_wr_xact_queue
 and active_rd_xact_queue is full. The sequence also instantiates the slave built-in memory,
 and writes into or reads from the slave memory.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_random_snoop_sequence.html">svt_axi_slave_random_snoop_sequence</a></td>
  <td class="compvalue">This sequence generates random snoop requests. This sequence
 gets the snoop object from the interconnect, randomizes it and provides 
 the randomized transaction to the slave port of the interconnect. This sequence 
 runs forever, and so is not registered with the slave sequence library
 .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_tlm_response_sequence.html">svt_axi_slave_tlm_response_sequence</a></td>
  <td class="compvalue">This sequence is used as Reactive seuqnce which translates slave transactions into
 corresponding AMBA-PV extended TLM Generic Payload Transactions and forwards it via
 the resp_socket socket for fulfillment by an AMBA-PV Slave.
 The response returned by the socket is then sent back to the driver.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_slave_wr_rd_memory_response_sequence.html">axi_slave_wr_rd_memory_response_sequence</a></td>
  <td class="compvalue">Abstract:
 Class axi_slave_wr_rd_memory_response_sequence defines a sequence class that
 the testbench uses to provide slave response to the Slave agent present in
 the System agent. The sequence receives a response object of type
 svt_axi_slave_transaction from slave sequencer. The sequence class then
 randomizes the response with constraints and provides it to the slave driver
 within the slave agent. The sequence also instantiates the slave built-in
 memory, and writes into the slave memory when the response randomized to OKAY when the xact_type is {WRITE, COHERENT} or
 reads from the memory.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_diff_write_resp_for_diff_masters_sequence.html">svt_axi_slave_diff_write_resp_for_diff_masters_sequence</a></td>
  <td class="compvalue">This sequence responds out-of-order and issues OKAY response for multiple write
 transactions from master M0 and SLVERR response for multiple write transactions from
 master M1.
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_get_xact_request_sequence.html">svt_axi_slave_get_xact_request_sequence</a></td>
  <td class="compvalue">This sequence trigger event(xact_request_received_event) when transaction 
 request is received to communicate the other block.
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_suspend_write_response_on_address_sequence.html">svt_axi_slave_suspend_write_response_on_address_sequence</a></td>
  <td class="compvalue">This sequence suspends the response of write transaction and resumes it, 
 after sending the response of immediate read transaction.
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_suspend_read_response_on_address_sequence.html">svt_axi_slave_suspend_read_response_on_address_sequence</a></td>
  <td class="compvalue">This sequence suspends the response of write transaction and resumes it, 
 after sending the response of immediate read transaction.
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_suspend_read_response_sequence.html">svt_axi_slave_suspend_read_response_sequence</a></td>
  <td class="compvalue">This sequence suspends the response of write transaction and resumes it, 
 after sending the response of immediate read transaction.
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_suspend_write_response_sequence.html">svt_axi_slave_suspend_write_response_sequence</a></td>
  <td class="compvalue">This sequence suspends the response of write transaction and resumes it, 
 after sending the response of immediate read transaction.
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_memory_suspend_response_sequence.html">svt_axi_slave_memory_suspend_response_sequence</a></td>
  <td class="compvalue">This sequence suspends the response of write transaction ,resumes it after 
 after read transactions reaches the slave. 
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_read_data_fixed_interleave_block_sequence.html">svt_axi_slave_read_data_fixed_interleave_block_sequence</a></td>
  <td class="compvalue">This sequence generates read interleaved data with interleave size of each
 block equal to one by default. User can modify the interleave block size by
 setting <a class="ClassLink" href="./sequences/class_svt_axi_slave_read_data_fixed_interleave_block_sequence.html#item_interleave_block_size">interleave_block_size</a>.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_programmed_response_sequence.html">svt_axi_slave_programmed_response_sequence</a></td>
  <td class="compvalue">This sequence gets the slave response sequence item from slave sequencer.
 User can modify these responses. The sequence uses the built-in slave memory. 
 For write transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_okay_slverr_resp_sequence.html">svt_axi_slave_okay_slverr_resp_sequence</a></td>
  <td class="compvalue">This sequence asserts slave response.
 This sequence gets the slave response sequence item from slave sequencer.
 The slave responds as OKAY response for first write transaction and SLVERR
 response for second write transaction. The sequence uses the built-in slave memory.
 For write transactions, it writes the data into slave memory. The programmed response
 is then provided to the slave driver.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_exclusive_sequence.html">svt_axi_slave_exclusive_sequence</a></td>
  <td class="compvalue">This sequence is used for the exclusive transactions. It gets the slave
 response sequence item from slave sequencer. F?or exclusive access
 transactions, response is not randomized as the response is pre-computed by
 the slave, based on exclusive access monitors. If the pre-computed response
 is modified, the response may not comply with exclusive access rules. For
 read transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. For normal transactions,
 randomized response provided to the slave driver. This sequence runs
 forever, and so is not registered with the slave sequence library.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_traffic_profile_sequence.html">svt_axi_slave_traffic_profile_sequence</a></td>
  <td class="compvalue">This sequence is used by the VIP to map traffic profile properties to AXI
 transaction properties. Traffic profile attributes are modelled as properties of
 this sequence. These are mapped to transaction level properties in the body of
 the sequence. Users could potentially use this sequence even if 
 traffic profiles are not used if the attributes of this sequence map to
 the requirements of modelling the response parameters of slaves in their system</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_memory_sequence.html">svt_axi_slave_memory_sequence</a></td>
  <td class="compvalue">This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_response_sequence.html">svt_axi_slave_response_sequence</a></td>
  <td class="compvalue">This sequence generates random responses to response requests. This sequence
 gets the slave response sequence item from slave sequencer, randomizes the
 response, and provides the randomized response to the slave driver.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_base_sequence.html">svt_axi_slave_base_sequence</a></td>
  <td class="compvalue">This sequence raises/drops objections in the pre/post_body so that root
 sequences raise objections but subsequences do not. All other slave sequences
 in the collection extend from this base sequence.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_tlm_generic_payload_pv_sequence.html">svt_axi_tlm_generic_payload_pv_sequence</a></td>
  <td class="compvalue">This sequence generates UVM TLM Generic Payload Transactions.
 A WRITE transaction is followed by a READ transaction to the same address. 
 At the end constraints and write and read data is compared are checked at the PV slave side</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_tlm_generic_payload_sequence.html">svt_axi_tlm_generic_payload_sequence</a></td>
  <td class="compvalue">This sequence generates UVM TLM Generic Payload Transactions.
 A WRITE transaction is followed by a READ transaction to the same address. 
 At the end of the READ transaction we check that the contents of the READ
 transaction are same as the WRITE transaction </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_service_random_coherency_exit_sequence.html">svt_axi_service_random_coherency_exit_sequence</a></td>
  <td class="compvalue">
 svt_axi_service_random_coherency_exit_sequence:

<ul><li>
 This sequence generates Coherency Exit service requests.

</li><li>
 Number of Coherency Exit service requests to be generated will be inferred from the attribute sequence_length which can be set to zero or greater than zero.

</li><li>
 sequence_length set to zero causes the sequence to run throughout the simulation. 

</li><li>
 This sequence does not raise and drop objections, so will not block simulation exit directly. 

</li><li>
 Delay attributes to control the number of clock cycles before sequence initiates subsequent coherency exit service request from the sequence, which can be set through config DB:

<ul><li>
 Minimum delay in clock cycles to initiate a Coherency Exit request from the point where the Sysco interface enters COHERENCY_ENABLED_STATE is inferred from the attribute coherency_exit_svc_req_min_delay.

</li><li>
 Maximum delay in clock cycles to initiate a Coherency Exit request from the point where the Sysco interface enters COHERENCY_ENABLED_STATE is inferred from the attribute coherency_exit_svc_req_max_delay.

</li></ul>


</li><li>
 The above mentioned attributes (sequence_length, coherency_exit_svc_req_min_delay, coherency_exit_svc_req_min_delay) can be set through config DB.

</li><li>
 Functionality: (following steps will be in a loop of sequence_length or forever loop if sequence_length is set to 0)

<ul><li>
 Wait for coherency state to be COHERENCY_ENABLED_STATE

<ul><li>
 Note that entry to coherency enabled state is expected to happen due to master transaction sequencer sending a cacheable transaction to driver, which causes the driver to initiate Coherency entry. 

</li></ul>


</li><li>
 Apply random delay between the programmed min and max delays

</li><li>
 Initiate Coherency Exit service request

</li></ul>


</li><li>
 This sequence will run on the svt_axi_service_sequencer.

</li><li>
 Default Values: (Note: Required values can be programmed through config DB)

<ul><li>
 sequence_length set to value between 1 and 10 upon randomization

</li><li>
 coherency_exit_svc_req_min_delay set to 1000

</li><li>
 coherency_exit_svc_req_max_delay set to 2000

</li></ul>


</li></ul>
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_service_coherency_entry_sequence.html">svt_axi_service_coherency_entry_sequence</a></td>
  <td class="compvalue">
 svt_axi_service_coherency_entry_sequence
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_service_coherency_exit_sequence.html">svt_axi_service_coherency_exit_sequence</a></td>
  <td class="compvalue">
 svt_axi_service_coherency_exit_sequence
 This sequence creates a coherency_exit svt_axi_service request.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_id_addr_test_sequence.html">svt_axi_exclusive_id_addr_test_sequence</a></td>
  <td class="compvalue">This sequence follows id_addr's transactions parallelly and other configurations set from the test. </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_sameid_outoforder_test_sequence.html">svt_axi_exclusive_sameid_outoforder_test_sequence</a></td>
  <td class="compvalue">This sequence performs the following
 1) Exclusive read transaction with ID 1 
 2) Exclusive read transaction with ID 1 and address nonoverlapping to the
 address of previous Exclusive read
 3) Exclusive write transaction matching to second Exclusive read with ID 1
 4) Exclusive write transaction matching to first Exclusive read with ID 1</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_sameid_outoforder_overlapping_test_sequence.html">svt_axi_exclusive_sameid_outoforder_overlapping_test_sequence</a></td>
  <td class="compvalue">This sequence performs the following
 1) Exclusive read transaction with ID 1 
 2) Exclusive read transaction with ID 1 and address overlapping to the
 address of previous Exclusive read
 3) Exclusive write transaction matching to second Exclusive read with ID 1
 4) Exclusive write transaction matching to first Exclusive read with ID 1</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_outoforder_overlapping_test_sequence.html">svt_axi_exclusive_outoforder_overlapping_test_sequence</a></td>
  <td class="compvalue">This sequence performs the following
 1) Exclusive read transaction with ID 1 
 2) Exclusive read transaction with ID 2 and address overlapping to the
 address of previous Exclusive read
 3) Exclusive write transaction matching to Exclusive read with ID 2
 4) Exclusive write transaction matching to Exclusive read with ID 1</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_sameid_inorder_test_sequence.html">svt_axi_exclusive_sameid_inorder_test_sequence</a></td>
  <td class="compvalue">This sequence performs the following
 1) Exclusive read transaction with ID 1 
 2) Exclusive read transaction with ID 1 and address nonoverlapping to the
 address of previous Exclusive read
 3) Exclusive write transaction matching to first Exclusive read with ID 1
 4) Exclusive write transaction matching to second Exclusive read with ID 2</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_sameid_inorder_overlapping_test_sequence.html">svt_axi_exclusive_sameid_inorder_overlapping_test_sequence</a></td>
  <td class="compvalue">This sequence performs the following
 1) Exclusive read transaction with ID 1 
 2) Exclusive read transaction with ID 1 and address overlapping to the
 address of previous Exclusive read
 3) Exclusive write transaction matching to first Exclusive read with ID 1
 4) Exclusive write transaction matching to second Exclusive read with ID 1</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_inorder_overlapping_test_sequence.html">svt_axi_exclusive_inorder_overlapping_test_sequence</a></td>
  <td class="compvalue">This sequence performs the following
 1) Exclusive read transaction with ID 1 
 2) Exclusive read transaction with ID 2 and address overlapping to the
 address of previous Exclusive read
 3) Exclusive write transaction matching to Exclusive read with ID 1
 4) Exclusive write transaction matching to Exclusive read with ID 2</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_read_without_write_test_sequence.html">svt_axi_exclusive_read_without_write_test_sequence</a></td>
  <td class="compvalue">This sequence performs the following
 1) Exclusive read transaction for which Exclusive write is not generated
 2) Exclusive read transaction with different ID and address compared to
 previous Exclusive read
 3) Exclusive write transaction with same ID, ADDR and other control fields as
 second Exclusive read</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_sameid_overlapping_normalwr_test_sequence.html">svt_axi_exclusive_sameid_overlapping_normalwr_test_sequence</a></td>
  <td class="compvalue">This sequence performs the following
 1) Exclusive read transaction
 2) Normal write transaction with same ID and overlapping ADDR 
 3) Exclusive write transaction with same ID, ADDR and other control fields as
 previous Exclusive read</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_sameid_normalwr_test_sequence.html">svt_axi_exclusive_sameid_normalwr_test_sequence</a></td>
  <td class="compvalue">This sequence performs the following
 1) Exclusive read transaction
 2) Normal write transaction with same ID and nonoverlapping ADDR 
 3) Exclusive write transaction with same ID, ADDR and other control fields as
 previous Exclusive read</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_max_req_test_sequence.html">svt_axi_exclusive_max_req_test_sequence</a></td>
  <td class="compvalue">This sequence performs number of Exclusive read and write transactions more than max_num_exclusive_access
 i.e. maximum number of active exclusive access monitors supported by the slave. </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_watchdog_timer_test_sequence.html">svt_axi_exclusive_watchdog_timer_test_sequence</a></td>
  <td class="compvalue">This sequence performs the following 
 1) Exclusive read transaction 
 2) Normal read and write transactions
 3) Exclusive write transaction </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_exclusive_read_write_mismatch_test_sequence.html">svt_axi_exclusive_read_write_mismatch_test_sequence</a></td>
  <td class="compvalue">This sequence performs Exclusive read transaction followed by Exclusive
 write transaction with different control fields as previous Exclusive read.
 Exclusive write commences only after response for Exclusive read is
 received by the master.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_sanity_test_sequence.html">svt_axi_master_sanity_test_sequence</a></td>
  <td class="compvalue">This sequence performs reads and writes in parallel</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_awakeup_same_wvalid_sequence.html">axi_awakeup_same_wvalid_sequence</a></td>
  <td class="compvalue">Abstract:
 class axi_awakeup_same_wvalid_sequence defines a sequence that generates a
 WRITE transactions with awakeup signal and wvalid signal at same clock cycle. This sequence is used by the
 axi_master_random_discrete_virtual_sequence which is set up as the default
 sequence for this environment.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_awakeup_same_axvalid_sequence.html">axi_awakeup_same_axvalid_sequence</a></td>
  <td class="compvalue">Abstract:
 class axi_awakeup_same_axvalid_sequence defines a sequence that generates a
 READ/WRITE transactions with awakeup and awvalid signals at same clock cycle. 
 This sequence is used by the axi_master_random_discrete_virtual_sequence 
 which is set up as the default sequence for this environment.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_awakeup_after_axvalid_sequence.html">axi_awakeup_after_axvalid_sequence</a></td>
  <td class="compvalue">Abstract:
 class axi_awakeup_after_axvalid_sequence defines a sequence that generates a
 READ/WRITE transactions with awakeup signal after awvalid signal. 
 This sequence is used by the axi_master_random_discrete_virtual_sequence 
 which is set up as the default sequence for this environment.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_awakeup_after_wvalid_sequence.html">axi_awakeup_after_wvalid_sequence</a></td>
  <td class="compvalue">Abstract:
 class axi_awakeup_after_wvalid_sequence defines a sequence that generates a
 WRITE type of transactions with awakeup signal after wvalid signal . 
 This sequence is used by the axi_master_random_discrete_virtual_sequence 
 which is set up as the default sequence for this environment.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_awakeup_before_wvalid_sequence.html">axi_awakeup_before_wvalid_sequence</a></td>
  <td class="compvalue">Abstract:
 class axi_awakeup_before_wvalid_sequence defines a sequence that generates a
 WRITE transactions with awakeup signals before wvalid signals. This sequence is used by the
 axi_master_random_discrete_virtual_sequence which is set up as the default
 sequence for this environment.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_awakeup_before_axvalid_sequence.html">axi_awakeup_before_axvalid_sequence</a></td>
  <td class="compvalue">Abstract:
 class axi_awakeup_before_axvalid_sequence defines a sequence that generates a
 transactions with awakeup signals before axvalid signals. This sequence is used by the
 axi_master_random_discrete_virtual_sequence which is set up as the default
 sequence for this environment.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi5_unique_id_different_id_all_unique_id_sequence.html">svt_axi5_unique_id_different_id_all_unique_id_sequence</a></td>
  <td class="compvalue">This sequence will generate the write transactions followed by 
 read transactions, where write/read unique ids are generated. 
 All other transaction fields are randomized.The number of write 
 and read transactions are defined by no_of_xacts, which is
 based on ID width and other configurations set from the tests are 
 use_separate_rd_wr_chan_id_width=random and num_outstanding_xact=random
 .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi5_unique_id_same_id_all_unique_id_sequence.html">svt_axi5_unique_id_same_id_all_unique_id_sequence</a></td>
  <td class="compvalue">This sequence will generate the parallel write_read transactions, 
 where write/read unique same ids are generated. All other transaction 
 fields are randomized.The other configurations set from the tests are 
 use_separate_rd_wr_chan_id_width=random and num_outstanding_xact=random
 .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi5_unique_id_separate_id_separate_num_outstanding_wr_rd_sequence.html">svt_axi5_unique_id_separate_id_separate_num_outstanding_wr_rd_sequence</a></td>
  <td class="compvalue">This sequence uses a sub-sequence "svt_axi5_unique_id_sequence" 
 This sequence will generate random read and write type of transaction 
 where id is generated from separate id channels and ids generated are random.
 unique_id is also set randomly for the transactions,
 other configurations set from the tests are 
 use_separate_rd_wr_chan_id_width=1 and num_outstanding_xact =-1
 .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi5_unique_id_same_id_directed_sequence.html">svt_axi5_unique_id_same_id_directed_sequence</a></td>
  <td class="compvalue">This sequence generates first two write -read transactions pair with unique_id '1'
 and remaining other transaction with unique_id '0'.
 All the write and read transactions have id value as '0'.
 This write and read transaction pair is repeated for sequence_length
 .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi5_unique_id_sequence.html">svt_axi5_unique_id_sequence</a></td>
  <td class="compvalue">This sequence will generate random read and write type of transaction 
 where id is generated from separate id channels and ids generated are random.
 unique_id is also set randomly for the transactions
 other configurations set from the tests are 
 use_separate_rd_wr_chan_id_width=1 and num_outstanding_xact =-1
 .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi5_unique_id_wr_rd_outstanding_sequence.html">svt_axi5_unique_id_wr_rd_outstanding_sequence</a></td>
  <td class="compvalue">Sequence for the test
 This sequence will generate the write transaction followed by read
 transaction. Write transaction will have different IDs and Read transaction will use the same IDs used by writes.
 The number of Write and Read transaction is defined by no_of_xacts. which is
 equal to the outstanding queue size. ID width will be limited to size of the outstanding queue.
 Hence there will be a pattern if num_max_outstanding_xact=2 
 WR(ID0,ID1),RD(ID0,ID1),WR(ID0,ID1),RD(ID0,ID1) etc..
 Unique_id is set to 1 for alternate writes transactions and similarly for reads transactions
 .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_unique_id_random_sequence.html">svt_axi_unique_id_random_sequence</a></td>
  <td class="compvalue">This sequence will generate random id based on enum of id_pattern as
 DIFF - Different id's
 SET_OF_SEQ_ID - Set of sequential id's
 SET_OF_REPT_ID - Set of repeated id's
 SET_OF_SAME_ID - Set of same id's
 RD_WR_CHAN_MIN_ID - Read or Write channel minimum id width range id's
 .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_unique_id_wr_rd_sequence.html">svt_axi_unique_id_wr_rd_sequence</a></td>
  <td class="compvalue">Abstract:
 class svt_axi_unique_id_wr_rd_sequence defines a sequence that generates a
 transactions with unique id signals. This sequence is used by the
 axi_master_random_discrete_virtual_sequence which is set up as the default
 sequence for this environment.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_chunking_same_id_sequence.html">svt_axi_master_chunking_same_id_sequence</a></td>
  <td class="compvalue">Abstract:
 class svt_axi_master_chunking_same_id_sequence defines a sequence that generates a
 wr/rd transactions with same id for read data chunking. This sequence used to generate 
 error scenario to validate read data chunking checker for arid cannot be same for 
 outstanding transaction. This sequence is used by the axi_master_random_discrete_virtual_sequence 
 which is set up as the default sequence for this environment.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_chunk_reorder_sequence.html">svt_axi_master_chunk_reorder_sequence</a></td>
  <td class="compvalue">This sequence performs write transaction followed by read transaction of read data chunking for directed scenario.
 Using this sequence, generating wr/rd transaction with specific burst_length, burst_size and data so that we can 
 generate out of order transaction using slave response sequence for read data chunking.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_master_rdata_chunk_err_sequence.html">axi_master_rdata_chunk_err_sequence</a></td>
  <td class="compvalue">Abstract:
 class axi_master_rdata_chunk_err_sequence defines a sequence that generates a
 error transactions with read data chunking. This sequence used to generate 
 error scenarios to validate checkers of red data chunking feature. This sequence 
 is used by the axi_master_random_discrete_virtual_sequence which is set up as 
 the default sequence for this environment.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_master_rdata_chunk_wr_rd_sequence.html">axi_master_rdata_chunk_wr_rd_sequence</a></td>
  <td class="compvalue">Abstract:
 class axi_master_rdata_chunk_wr_rd_sequence defines a sequence that generates a
 transactions with read data chunking signals. This sequence is used by the
 axi_master_random_discrete_virtual_sequence which is set up as the default
 sequence for this environment.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_master_atomic_swap_xact_base_sequence.html">axi_master_atomic_swap_xact_base_sequence</a></td>
  <td class="compvalue">This sequence generates atomic swap transactions.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_master_atomic_compare_xact_base_sequence.html">axi_master_atomic_compare_xact_base_sequence</a></td>
  <td class="compvalue">This sequence generates atomic compare transactions.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_master_atomic_load_xact_base_sequence.html">axi_master_atomic_load_xact_base_sequence</a></td>
  <td class="compvalue">This sequence generates atomic load transactions.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_master_atomic_store_xact_base_sequence.html">axi_master_atomic_store_xact_base_sequence</a></td>
  <td class="compvalue">This sequence generates atomic store transactions.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi3_master_random_read_write_locked_sequence.html">svt_axi3_master_random_read_write_locked_sequence</a></td>
  <td class="compvalue">This sequence performs locked accesses 
 Each loop does the following:
 Send a random locked access transaction.
 Send the exclusive transaction with same xact_type and address as of locked transaction to unlock the locked sequence
 Each transcation waits for the previous transaction to be ended
 Note that user needs to constraint slv_num as targeted slave id, 
 or set target_slv through uvm_config_db.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_transaction_sequence_library.html">svt_axi_master_transaction_sequence_library</a></td>
  <td class="compvalue">AXI VIP provides a pre-defined AXI Master sequence library
 svt_axi_master_transaction_sequence_library, which can hold the AXI Master
 sequences. The library by default has no registered sequences. You are
 expected to call
 <a class="ClassLink" href="./sequences/class_svt_axi_master_transaction_sequence_library.html">svt_axi_master_transaction_sequence_library</a> <b>::</b> <a class="ClassLink" href="./sequences/class_svt_axi_master_transaction_sequence_library.html#item_populate_library">populate_library</a> method to
 populate the sequence library with master sequences provided with the VIP. The
 port configuration is provided to the <a class="ClassLink" href="./sequences/class_svt_axi_master_transaction_sequence_library.html#item_populate_library">populate_library</a> method as an
 argument. Based on the port configuration, appropriate sequences are added to
 the sequence library. You can then load the sequence library in the sequencer
 within the master agent.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_snoop_base_sequence.html">svt_axi_master_snoop_base_sequence</a></td>
  <td class="compvalue">AXI ACE base master snoop response reactive sequence</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_locked_read_followed_by_excl_sequence.html">svt_axi_master_locked_read_followed_by_excl_sequence</a></td>
  <td class="compvalue">This sequence performs locked followed by exclusive accesses 
 Each loop does the following:
 Send a locked access read transaction followed by a excluisve read transaction
 Send the exclusive read transactions with same id as of locked read transaction
 Each transcation waits for the previous transaction to be ended
 Note that user needs to constraint slv_num as targeted slave id, 
 or set target_slv through uvm_config_db.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_normal_exclusive_random_sequence.html">svt_axi_master_normal_exclusive_random_sequence</a></td>
  <td class="compvalue">This sequence performs the following
 send back to back four transactions
 The atomic type is randomized to exclusive or normal for each transaction
 Note that user needs to constraint slv_num as targeted slave id, 
 or set target_slv through uvm_config_db.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_locked_test_sequence.html">svt_axi_master_locked_test_sequence</a></td>
  <td class="compvalue">This sequence performs locked accesses 
 Each loop does the following:
 Send a normal transaction
 Send a locked access transaction that starts the locked sequeunce
 Send more locked access transactions
 Send a normal transactions that ends the locked sequence
 An intermediate loop sends only NORMAL transactions (represented by k == 5)</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_exclusive_normal_wrap_test_sequence.html">svt_axi_master_exclusive_normal_wrap_test_sequence</a></td>
  <td class="compvalue">This sequence performs the following
 1) Exclusive read transaction with WRAP burst type 
 2) Normal write transaction with different ID and address overlapping to the
 address of previous exclusive read
 3) Exclusive write transaction matching to the previous Exclusive read</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_exclusive_read_after_read_test_sequence.html">svt_axi_master_exclusive_read_after_read_test_sequence</a></td>
  <td class="compvalue">This sequence performs the following
 1) Series of Exclusive read transactions 
 2) Series of Exclusive write transactions </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_exclusive_memory_test_sequence.html">svt_axi_master_exclusive_memory_test_sequence</a></td>
  <td class="compvalue">This sequence performs the following 
 1) Exclusive read transaction
 2) Normal write transaction with same ID, ADDR and other control fields as
 previous Exclusive read
 3) Exclusive write transaction with same ID, ADDR and other control fields as
 previous Exclusive read</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_exclusive_random_test_sequence.html">svt_axi_master_exclusive_random_test_sequence</a></td>
  <td class="compvalue">This sequence performs the following 
 1) Normal read and write transactions 
 2) Exclusive read and write transactions 
 3) Normal read and write transactions 
 4) Exclusive read and write transactions </td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_exclusive_test_sequence.html">svt_axi_master_exclusive_test_sequence</a></td>
  <td class="compvalue">This sequence performs Exclusive read transaction followed by Exclusive
 write transaction with same control fields as previous Exclusive read.
 Exclusive write commences only after response for Exclusive read is
 received by the master.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_aligned_addr_sequence.html">svt_axi_master_aligned_addr_sequence</a></td>
  <td class="compvalue">This sequence generates the transactions whose address is always aligned with
 respect to burst size.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_write_data_before_addr_sequence.html">svt_axi_master_write_data_before_addr_sequence</a></td>
  <td class="compvalue">This sequence generates write data before address. This is valid when
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_category">axi_interface_category</a> = AXI_READ_WRITE or
 AXI_WRITE_ONLY.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_write_data_fixed_interleave_block_sequence.html">svt_axi_master_write_data_fixed_interleave_block_sequence</a></td>
  <td class="compvalue">This sequence generates write interleaved data with interleave size of each
 block equal to one by default. User can modify the interleave block size by
 setting <a class="ClassLink" href="./sequences/class_svt_axi_master_write_data_fixed_interleave_block_sequence.html#item_interleave_block_size">interleave_block_size</a>. This is valid when
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> = AXI3.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_blocking_alternate_write_read_sequence.html">svt_axi_master_blocking_alternate_write_read_sequence</a></td>
  <td class="compvalue">This sequence generates alternate write and read transaction. All other
 transaction fields are randomized. The sequence waits for each transaction
 to complete, before sending the next transaction. This sequence is valid
 only when <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_category">axi_interface_category</a> =
 AXI_READ_WRITE.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_outstanding_snoop_xacts_sequence.html">svt_axi_master_outstanding_snoop_xacts_sequence</a></td>
  <td class="compvalue">This sequence generates a sequence of coherent READONCE transactions.
 All other transaction fields are randomized. The sequence does not wait for transactions
 to complete before sending next transaction. This is required in order to generate 
 outstanding snoop transactions. This sequence is targetted to hit the following
 covergroups.
 <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html#item_trans_ace_num_outstanding_snoop_xacts">trans_ace_num_outstanding_snoop_xacts</a>
 This sequence requires <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_category">axi_interface_category</a> is set to 
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_READ_WRITE">AXI_READ_WRITE</a> or <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_READ_ONLY">AXI_READ_ONLY</a>
 and <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> is set to AXI_ACE or ACE_LITE.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_outstanding_dvm_tlb_invalidate_xacts_sequence.html">svt_axi_master_outstanding_dvm_tlb_invalidate_xacts_sequence</a></td>
  <td class="compvalue">This sequence generates a sequence of DVM TLB Invalidate transactions.
 All other transaction fields are randomized. The sequence does not wait for transactions
 to complete before sending next transaction. This is required in order to generate 
 outstanding DVM TLBI transactions. This sequence is targetted to hit the following
 covergroups.
 <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html#item_trans_ace_num_outstanding_dvm_tlb_invalidate_xacts_with_same_arid">trans_ace_num_outstanding_dvm_tlb_invalidate_xacts_with_same_arid</a>
 <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html#item_trans_ace_num_outstanding_dvm_tlb_invalidate_xacts_with_diff_arid">trans_ace_num_outstanding_dvm_tlb_invalidate_xacts_with_diff_arid</a>
 This sequence requires <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_category">axi_interface_category</a> = <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_READ_WRITE">AXI_READ_WRITE</a>
 and <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> is either ACE or ACE-Lite.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_outstanding_xact_id_sequence.html">svt_axi_master_outstanding_xact_id_sequence</a></td>
  <td class="compvalue">This sequence generates a sequence of coherent writenosnoop transactions,
 followed by coherent readnosnoop transactions. All other transaction fields
 are randomized. The sequence does not wait for transactions to complete
 before sending next transaction. This is required in order to generate 
 outstanding transactions. This sequence is targetted to hit the following
 covergroups.
 <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html#item_trans_axi_num_outstanding_xacts_with_same_arid">trans_axi_num_outstanding_xacts_with_same_arid</a>
 <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html#item_trans_axi_num_outstanding_xacts_with_diff_arid">trans_axi_num_outstanding_xacts_with_diff_arid</a>
 <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html#item_trans_axi_num_outstanding_xacts_with_same_awid">trans_axi_num_outstanding_xacts_with_same_awid</a>
 <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html#item_trans_axi_num_outstanding_xacts_with_diff_awid">trans_axi_num_outstanding_xacts_with_diff_awid</a>
 <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html#item_trans_axi_num_outstanding_xacts_with_multiple_same_arid">trans_axi_num_outstanding_xacts_with_multiple_same_arid</a>
 <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="./callback/class_svt_axi_port_monitor_def_cov_callback.html#item_trans_axi_num_outstanding_xacts_with_multiple_same_awid">trans_axi_num_outstanding_xacts_with_multiple_same_awid</a>
 This sequence requires <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_category">axi_interface_category</a> = <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_AXI_READ_WRITE">AXI_READ_WRITE</a>
 and <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> is either ACE or ACE-Lite.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_master_wr_rd_single_outstanding_per_id_sequence.html">axi_master_wr_rd_single_outstanding_per_id_sequence</a></td>
  <td class="compvalue">This sequence generates parallel write_read transactions,
 mainly with non_overlapping address and same ids. All other transaction 
 fields are randomized. The sequence wait for write/read transactions 
 to complete before sending next write/read transaction. This is required 
 in order to generate outstanding transactions
 .</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_blocking_write_read_sequence.html">svt_axi_master_blocking_write_read_sequence</a></td>
  <td class="compvalue">This sequence generates a sequence of write transactions, followed by a
 sequence of read transactions. All other transaction fields are randomized.
 The sequence waits for each transaction to complete, before sending the next
 transaction. This sequence is valid only when
 <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="./configuration/class_svt_axi_port_configuration.html#item_axi_interface_category">axi_interface_category</a> = AXI_READ_WRITE.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_axi_master_wr_rd_parallel_sequence.html">axi_master_wr_rd_parallel_sequence</a></td>
  <td class="compvalue">This sequence generates parallel write_read transactions,
 mainly with non_overlapping address. All other transaction 
 fields are randomized. The sequence initially sends 10 write transactions , waits for them to complete,
 then sends 10 read transactions waits for them to complete, then sends thousands of write and 
 read transactions in parallel without waiting for them to complete.
 This is required in order to create different scenarios of outstanding transactions.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_read_same_slave_sequence.html">svt_axi_read_same_slave_sequence</a></td>
  <td class="compvalue">This sequence generates a Read transactions with overlapping addr/non overlapping
 addr/random addr to the same slave. Remaining fields are randomized.
 It generates the write followed by read transaction and waiting for write transaction
 to complete,then execute the read transaction with same write transaction accessing address.
 Note that user needs to constraint slv_num as targeted slave id, 
 or set target_slv through uvm_config_db.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_write_same_slave_sequence.html">svt_axi_write_same_slave_sequence</a></td>
  <td class="compvalue">This sequence generates a Write transactions with overlapping addr/non overlapping
 addr/random addr to the same slave. Remaining fields are randomized.
 Note that user needs to constraint slv_num as targeted slave id, 
 or set target_slv through uvm_config_db.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_random_sequence.html">svt_axi_random_sequence</a></td>
  <td class="compvalue">This sequence generates a random sequences of write transaction or 
 of read transaction. All other transaction fields are randomized.
 Note that user needs to constraint slv_num as targeted slave id, 
 or set target_slv through uvm_config_db.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_random_sequence.html">svt_axi_master_random_sequence</a></td>
  <td class="compvalue">This sequence generates random master transactions.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_read_xact_sequence.html">svt_axi_ace_master_read_xact_sequence</a></td>
  <td class="compvalue">This sequence generates a single random ACE read transaction.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_write_xact_sequence.html">svt_axi_ace_master_write_xact_sequence</a></td>
  <td class="compvalue">This sequence generates a single random ACE write transaction.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_read_xact_sequence.html">svt_axi_master_read_xact_sequence</a></td>
  <td class="compvalue">This sequence generates a single random read transaction.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_write_xact_sequence.html">svt_axi_master_write_xact_sequence</a></td>
  <td class="compvalue">This sequence generates a single random write transaction.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_master_base_sequence.html">svt_axi_master_base_sequence</a></td>
  <td class="compvalue">This sequence raises/drops objections in the pre/post_body so that root
 sequences raise objections but subsequences do not. All other master sequences
 in the collection extend from this base sequence.</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_ace_master_snoop_response_sequence.html">svt_axi_ace_master_snoop_response_sequence</a></td>
  <td class="compvalue">Reactive response sequence that services snoop requests
 using the cache located in the parent svt_axi_master_snoop_sequencer.
 Automatically configured as the run_phase default sequence for every instance of
 the svt_axi_master_snoop_sequencer.
</td></tr>
</tr>
<tr>
  <td class="compkey"><a class="ClassLink" href="./sequences/class_svt_axi_slave_transaction_sequence_library.html">svt_axi_slave_transaction_sequence_library</a></td>
  <td class="compvalue">Sequence library for svt_axi_slave_transaction transaction. </td></tr>
</tr>
</table>
<hr size="1">
<address class='copyright'> 16 November 2023, Copyright &copy; 2023 Synopsys, Inc. </address>
<script>makeTableHeadersInPageSticky();</script>
<script>(function() {    var ssButton = document.querySelector('.smartsearch-btn');    var ssInfo = document.querySelector('.smartsearch-info');    var ssClose = document.querySelector('.smartsearch-info-close');    ssButton.addEventListener('click', function() {        ssInfo.style.display = 'block';    });    ssClose.addEventListener('click', function() {        ssInfo.style.display = 'none';    });    ssInfo.addEventListener('click', function(event) {        if (event.target === ssInfo) {            ssInfo.style.display = 'none';        }    });})();</script></body></html>
