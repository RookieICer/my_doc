<!DOCTYPE html ><html xml:lang="en" lang="en" data-highlight-require-whitespace="false" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><title>How to Provide Data and Response Information to the Slave After a Time Delay</title><link rel="Prev" href="06_using_AXI_VIP.10.03.html" title="Previous" /><link rel="Next" href="06_using_AXI_VIP.10.05.html" title="Next" /><link rel="StyleSheet" href="css/06_using_AXI_VIP.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/skin.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/social.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all" /><!--[if IE 7]><link rel="StyleSheet" href="css/06_using_AXI_VIP_IE7.css" type="text/css" media="all" /><![endif]--><link rel="StyleSheet" href="css/print.css" type="text/css" media="print" /><script type="text/javascript">
    'use strict';

    var redirect_url, page_hash;

    if ((window === window.top) && (window.navigator.userAgent.indexOf('bot/') === -1)) {
        // Redirect
        //
        redirect_url = "../index.html#page/axi_svt_uvm_user_guide/06_using_AXI_VIP.10.04.html";
        if (window.document.location.hash.length > 1) {
            // Sanitize and append it
            //
            page_hash = window.document.location.hash.substring(1);
            page_hash = page_hash.replace(/[\\><:;"]|%5C|%3C|%3E|%3A|%3B|%22/gi, '');

            // escape the '#' character
            //
            redirect_url += '%23' + page_hash;
        }
        window.document.location.replace(redirect_url);
    }
</script><script type="text/javascript" src="scripts/common.js"></script><script type="text/javascript" src="scripts/page.js"></script><script type="text/javascript" src="scripts/search-client.js"></script><script type="text/javascript" src="scripts/unidata.js"></script><script type="text/javascript" src="scripts/unibreak.js"></script><noscript><div id="noscript_padding"></div></noscript></head><body id="pwxv_002f_002fMoaTS4y45R1fbjz_002fA" class="ww_skin_page_body" onload="Page.OnLoad('../index.html#page/axi_svt_uvm_user_guide/06_using_AXI_VIP.10.04.html');"><header id="wwconnect_header"><div class="ww_skin_breadcrumbs"><a class="WebWorks_Breadcrumb_Link" href="01_Intro.01.1.html">AXI UVM User Guide</a> : <a class="WebWorks_Breadcrumb_Link" href="06_using_AXI_VIP.10.01.html#1107263"> Using AXI Verification IP</a> : How to Provide Data and Response Information to the Slave After a Time Delay</div><div class="ww_skin_page_toolbar"><a class="ww_behavior_print ww_skin ww_skin_print" title="Print" href="#">&nbsp;</a><a class="ww_behavior_email ww_skin ww_skin_email" title="E-Mail" href="#" target="external_window">&nbsp;</a></div></header><div id="ww1107263" class="H2">How to Provide Data and Response Information to the Slave After a Time Delay</div><div id="ww1107270" class="Body"><span></span>As a default behavior, the slave driver expects the slave response sequence to return the slave response object in zero time, that is, without any delay after the sequencer receives object from the port monitor. This poses a problem where data and response information may not be available immediately and therefore cannot be given in zero time.</div><div id="ww1107271" class="Body"><span></span>There are two alternatives to address this issue:</div><div id="ww1107272" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Using svt_axi_transaction::suspend_response:</div><div id="ww1107273" class="L1Body"><span></span>The users can use the member svt_axi_transaction::suspend_response to achieve this. This requires the user to fork off the threads which wait for data to become available. This option is recommended when user can provide data &amp; response information for all the beats in one shot to the slave driver, after a certain time delay, after receiving the slave response object from the port monitor.</div><div id="ww1107274" class="L1Bul"><span class="WebWorks_Number" style="width: 18pt"><span><img src="L1Bul.png" alt="*" border="0" width="9" height="8" /></span></span>Using svt_axi_port_configuration::enable_delayed_response_port:</div><div id="ww1107275" class="L1Body"><span></span>This option is recommended when user cannot provide data and response information for all the beats in one shot to the slave driver, after a certain time delay, after receiving slave response object from the port monitor. </div><div id="ww1107276" class="Body"><span></span>&nbsp;</div><div id="ww1107443" class="Body"><span></span>The following is the usage model for this feature.</div><div id="ww1107277" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>This feature will be enabled using a port level configuration parameter (svt_axi_port_configuration::enable_delayed_response_port). By default, this feature will be disabled.</div><div id="ww1107278" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>The slave monitor provides a handle to a transaction to the sequencer for the following events:</div><div id="ww1107279" class="L2Num"><span class="WebWorks_Number" style="width: 18pt"><span>a.	</span></span>Address phase of read/write transaction</div><div id="ww1107280" class="L2Num"><span class="WebWorks_Number" style="width: 18pt"><span>b.	</span></span>First beat of write data if the data arrives before address</div><div id="ww1107281" class="L1Body"><span></span>There is no change to this behavior.</div><div id="ww1107282" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>The model will still require that the handle to the transaction is returned to the driver in zero time. This is to ensure that the driver has enough information to drive signals such as arready and awready. However, read data and read/write response related information need not be populated at this time. The mechanism detailed in (4) below may be used for the same.</div><div id="ww1107283" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>4.	</span></span>A TLM port (uvm_blocking_get_port) is added to the slave driver, which enables the user to supply information related to read data and read/write response at a later point in time. This port is connected to a corresponding 'put' port (delayed_response_request_port) in the sequencer by the VIP. </div><div id="ww1107946" class="L1Body"><span></span>When the data and response information is available, the slave sequence can provide the slave response object using this 'put' port in the sequencer. The transaction supplied through this TLM port should NOT be the same transaction handle given by the monitor to the sequencer, but it should be its copy. The information related to data and response, refers to the following properties in svt_axi_transaction:</div><div id="ww1107284" class="L2Num"><span class="WebWorks_Number" style="width: 18pt"><span>a.	</span></span>data[]</div><div id="ww1107285" class="L2Num"><span class="WebWorks_Number" style="width: 18pt"><span>b.	</span></span>rresp[]</div><div id="ww1107286" class="L2Num"><span class="WebWorks_Number" style="width: 18pt"><span>c.	</span></span>coh_rresp[]</div><div id="ww1107287" class="L2Num"><span class="WebWorks_Number" style="width: 18pt"><span>d.	</span></span>rvalid_delay[]</div><div id="ww1107288" class="L2Num"><span class="WebWorks_Number" style="width: 18pt"><span>e.	</span></span>bresp</div><div id="ww1107289" class="L2Num"><span class="WebWorks_Number" style="width: 18pt"><span>f.	</span></span>bvalid_delay</div><div id="ww1107290" class="L1Body"><span></span>For READ transaction, a user will have the flexibility to input any number of beats at any point of time. The model detects an availability of data by checking the array size of rresp[] field. For example, if the size of array rresp[] is 1, it indicates that the first beat is available. If the size is two, it indicates that the first two beats are available and so on. The array sizes of all the above properties should be consistent and the responsibility to ensure this lies on the user. The model would allow the transaction to be submitted back to the p_sequencer multiple times, if partial beat information was received. It is user's responsibility to make sure that eventually all the read data required for read transaction to complete, is provided to the model.</div><div id="ww1107291" class="L1Body"><span></span>For WRITE transactions, a user has the ability to return the response (bresp) at any point of time.</div><div id="ww1107292" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>5.	</span></span>When the above feature is enabled, the constraints will not enforce array sizes of the above mentioned parameters to be consistent with burst length, since the array sizes will be used to recognize availability of data.</div><div id="ww1107293" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>6.	</span></span>When this feature is enabled, responses sent through the seq_item_port must have data.size() and rresp.size() as 0. That is, these arrays must be empty. In other words, all the response and data information must be sent through the delayed_response_request_port of the sequencer.</div><div id="ww1107958" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>7.	</span></span>If a transaction is randomized before it is sent through the delayed_response_request_port, the property svt_axi_transaction::is_delayed_response_xact must be set for the transaction (this transaction will be the copy of the transaction received from the monitor since only a copy is allowed on this port as mentioned below).</div><div id="ww1107295" class="L1Num"><span class="WebWorks_Number" style="width: 18pt"><span>8.	</span></span>The transaction provided through the delayed_response_request_port must be a copy of the original transaction and not a reference. The following fields of the original transaction received from the monitor and the delayed response should match: </div><div id="ww1107296" class="L1Body"><span></span>svt_axi_transaction::object_id</div><div id="ww1107297" class="L1Body"><span></span>svt_axi_transaction::id</div><div id="ww1107298" class="L1Body"><span></span>svt_axi_transaction::addr</div><div id="ww1107300" class="Body" style="color: #000000; font-style: normal; font-variant: normal; font-weight: bold; text-transform: none; vertical-align: baseline"><span></span>&nbsp;</div><div id="ww1108289" class="Body" style="color: #000000; font-style: normal; font-variant: normal; font-weight: bold; text-transform: none; vertical-align: baseline"><span></span><span style="color: #000000; font-family: &quot;Book Antiqua&quot;; font-size: 11.0pt; font-style: normal; font-variant: normal; font-weight: bold; text-transform: none; vertical-align: baseline">Sample code:</span></div><div id="ww1107301" class="Code">virtual task body();</div><div id="ww1107302" class="Code">      svt_axi_slave_transaction req_resp;</div><div id="ww1107303" class="Code">      forever</div><div id="ww1107304" class="Code">      begin</div><div id="ww1107305" class="Code">         p_sequencer.response_request_port.peek(req_resp);</div><div id="ww1107306" class="Code">         // Randomize the initial response. The response will be completed </div><div id="ww1107307" class="Code">         // after some time has elapsed, when the block that is external to the</div><div id="ww1107308" class="Code">         // slave returns data.</div><div id="ww1107309" class="Code">         status = req_resp.randomize (â€¦);</div><div id="ww1107310" class="Code">         fork</div><div id="ww1107311" class="Code">           svt_axi_slave_transaction delayed_resp;</div><div id="ww1107312" class="Code">          delayed_resp = svt_axi_slave_transaction::type_id::create("delayed slave &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response",p_sequencer);</div><div id="ww1107313" class="Code">          delayed_resp.copy(req_resp);</div><div id="ww1107314" class="Code">           begin</div><div id="ww1107315" class="Code">               if((delayed_resp.xact_type == svt_axi_slave_transaction::WRITE) &amp;&amp; </div><div id="ww1107316" class="Code">                   (delayed_resp.addr_status != svt_axi_transaction::INITIAL))</div><div id="ww1107317" class="Code">               //Provide the data to an external entity which will supply back the write &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response   </div><div id="ww1107318" class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put_write_transaction_data_to_external_block(delayed_resp);</div><div id="ww1107319" class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//After write response is available, provide it to &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delayed_response_request_port port</div><div id="ww1107320" class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight: bold">p_sequencer.delayed_response_request_port.put(delayed_resp);</span> </div><div id="ww1107321" class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Provide delayed write response</div><div id="ww1107322" class="Code">               else</div><div id="ww1107323" class="Code">               begin</div><div id="ww1107324" class="Code">               //Get the read data from an external entity</div><div id="ww1107325" class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get_read_data_from_external_block_to_transaction(delayed_resp);</div><div id="ww1107326" class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//After read data and response is available, provide it to &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delayed_response_request_port port</div><div id="ww1107327" class="Code"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight: bold">p_sequencer.delayed_response_request_port.put(delayed_resp);</span>  </div><div id="ww1107328" class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Provide delayed read data.</div><div id="ww1107329" class="Code">               end</div><div id="ww1107330" class="Code">            end</div><div id="ww1107331" class="Code">         end</div><div id="ww1107332" class="Code">       join_none</div><div id="ww1107333" class="Code">      $cast(req, req_resp);</div><div id="ww1107334" class="Code">     //User still needs to provide slave response object back to the slave driver in &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zero time. </div><div id="ww1107335" class="Code">     // This is to ensure that the driver has enough information to drive signals such &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as arready and awready. </div><div id="ww1107336" class="Code">     //Response and data information can be provided at a later time when &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;svt_axi_port_configuration::enable_delayed_response_port is set.</div><div id="ww1107337" class="Code">      </div><div id="ww1107457" class="Code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`uvm_send(req)</div><noscript><div id="noscript_warning">This site works best with JavaScript enabled</div></noscript><footer><!-- Related Topics --><!--                --><!-- Disqus --><!--        --><!-- Google Translation --><!--                    --><br /></footer><input type="hidden" id="preserve_unknown_file_links" value="false"></input></body></html>